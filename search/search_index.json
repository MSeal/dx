{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dx","text":"<p> dx is a data visualization library that allows you to create charts and dashboards using the Noteable's data explorer DEX. This package provides convenient formatting and IPython display formatter registration for tabular data and DEX media types. </p> <p> </p> <p>A Pythonic Data Explorer, open sourced with \u2764\ufe0f by Noteable, a collaborative notebook platform that enables teams to use and visualize data, together.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#poetry","title":"Poetry","text":"<pre><code>poetry add dx\n</code></pre> <p>Then import the package:</p> <pre><code>import dx\n</code></pre>"},{"location":"#pip","title":"Pip","text":"<pre><code>pip install dx\n</code></pre> <p>Then import the package:</p> <pre><code>import dx\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The <code>dx</code> library currently enables DEX media type visualization of pandas <code>DataFrame</code> and <code>Series</code> objects, as well as numpy <code>ndarray</code> objects. This can be handled in two ways:</p> <ul> <li>explicit <code>dx.display()</code> calls</li> <li>setting the <code>display_mode</code> to update the IPython display formatter for a session</li> </ul>"},{"location":"#with-dxdisplay","title":"With <code>dx.display()</code>","text":"<p><code>dx.display()</code> will display a single dataset using the DEX media type. It currently supports:</p> <ul> <li>pandas <code>DataFrame</code> objects</li> </ul> <pre><code>import pandas as pd\nimport random\n\ndf = pd.DataFrame({\n    'random_ints': [random.randint(0, 100) for _ in range(500)],\n    'random_floats': [random.random() for _ in range(500)],\n})\ndx.display(df)\n</code></pre> <p></p> <ul> <li>tabular data as <code>dict</code> or <code>list</code> types</li> </ul> <pre><code>dx.display([\n  [1, 5, 10, 20, 500],\n  [1, 2, 3, 4, 5],\n  [0, 0, 0, 0, 1]\n])\n</code></pre> <p></p> <ul> <li><code>.csv</code> or <code>.json</code> filepaths</li> </ul> <pre><code>df = dx.random_dataframe()\ndf.to_csv(\"dx_docs_sample.csv\", index=False)\n\ndx.display(\"dx_docs_sample.csv\")\n</code></pre> <p></p>"},{"location":"#with-dxset_display_mode","title":"With <code>dx.set_display_mode()</code>","text":"<p>Using either <code>\"simple\"</code> or <code>\"enhanced\"</code> display modes will allow <code>dx</code> will update the current <code>IPython</code> display formatters to allow DEX media type visualization of pandas <code>DataFrame</code> objects for an entire notebook / kernel session instead of the default <code>DataFrame</code> display output.</p> Details  This will adjust pandas options to:  - increasing the number of rows displayed to `50000` from pandas default of `60` - increasing the number of columns displayed to `50` from pandas default of `20` - enabling `html.table_schema` (`False` by default in pandas)  This will also handle some basic column cleaning and generate a schema for the `DataFrame` using `pandas.io.json.build_table_schema`. Depending on the display mode, the data will be transformed into either a list of dictionaries or list of lists of columnar values.  - `\"simple\"` - list of dictionaries - `\"enhanced\"` - list of lists  <p>NOTE: Unlike <code>dx.display()</code>, this only affects pandas DataFrames (or any types set in <code>settings.RENDERABLE_TYPES</code>); it does not affect the display of <code>.csv</code>/<code>.json</code> file data, or <code>dict</code>/<code>list</code> outputs</p> <ul> <li><code>dx.set_display_mode(\"simple\")</code></li> </ul> <pre><code>import dx\nimport numpy as np\nimport pandas as pd\n\n# enable DEX display outputs from now on\ndx.set_display_mode(\"simple\")\n\ndf = pd.read_csv(\"dx_docs_sample.csv\")\ndf\n</code></pre> <pre><code>df2 = pd.DataFrame(\n    [\n        [1, 5, 10, 20, 500],\n        [1, 2, 3, np.nan, 5],\n        [0, 0, 0, np.nan, 1]\n    ],\n    columns=['a', 'b', 'c', 'd', 'e']\n)\ndf2\n</code></pre> <p></p> <p>If, at any point, you want to go back to the default display formatting (vanilla pandas output), use the <code>\"plain\"</code> display mode. This will revert the IPython display format update to its original state and put the pandas options back to their default values.</p> <ul> <li><code>dx.set_display_mode(\"plain\")</code></li> </ul> <pre><code># revert to original pandas display outputs from now on\ndx.set_display_mode(\"plain\")\n\ndf = pd.read_csv(\"dx_docs_sample.csv\")\ndf\n</code></pre> <pre><code>df2 = pd.DataFrame(\n    [\n        [1, 5, 10, 20, 500],\n        [1, 2, 3, np.nan, 5],\n        [0, 0, 0, np.nan, 1]\n    ],\n    columns=['a', 'b', 'c', 'd', 'e']\n)\ndf2\n</code></pre> <p></p>"},{"location":"#custom-settings","title":"Custom Settings","text":"<p>Default settings for <code>dx</code> can be found by calling <code>dx.settings</code>: </p> <p>Each can be set using <code>dx.set_option()</code>:  Setting <code>DISPLAY_MAX_ROWS</code> to <code>3</code> for the current session</p> <p>...or with the <code>dx.settings_context()</code> context manager:  Setting <code>DISPLAY_MAX_ROWS</code> to <code>3</code> within the current context, leaving options for the rest of the session alone</p>"},{"location":"#generating-sample-data","title":"Generating Sample Data","text":"<p>Documentation coming soon!</p>"},{"location":"#usage-outside-of-noteable","title":"Usage Outside of Noteable","text":"<p>If using this package in a notebook environment outside of Noteable, the frontend should support the following media types:</p> <ul> <li><code>application/vnd.dataresource+json</code> for <code>\"simple\"</code> display mode</li> <li><code>application/vnd.dex.v1+json</code> for <code>\"enhanced\"</code> display mode</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.md.</p>"},{"location":"#code-of-conduct","title":"Code of Conduct","text":"<p>We follow the noteable.io code of conduct.</p>"},{"location":"#license","title":"LICENSE","text":"<p>See LICENSE.md.</p> <p>Open sourced with \u2764\ufe0f by Noteable for the community.</p> <p></p>"},{"location":"_charts/_template/","title":"template","text":""},{"location":"_charts/_template/#chart-name","title":"Chart Name","text":"<p>Coming soon!</p>"},{"location":"_charts/_template/#chart-name_1","title":"Chart Name","text":"<p>Coming soon!</p>"},{"location":"_charts/adjacency_matrix/","title":"Adjacency matrix","text":""},{"location":"_charts/adjacency_matrix/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/adjacency_matrix/#adjacency-matrix_1","title":"Adjacency Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/arc_diagram/","title":"Arc diagram","text":""},{"location":"_charts/arc_diagram/#arc-diagram","title":"Arc Diagram","text":"<p>Coming soon!</p>"},{"location":"_charts/arc_diagram/#arc-diagram_1","title":"Arc Diagram","text":"<p>Coming soon!</p>"},{"location":"_charts/arc_flow/","title":"Arc flow","text":""},{"location":"_charts/arc_flow/#arc-flow","title":"Arc Flow","text":"<p>Coming soon!</p>"},{"location":"_charts/arc_flow/#arc-flow_1","title":"Arc Flow","text":"<p>Coming soon!</p>"},{"location":"_charts/bar/","title":"Bar","text":""},{"location":"_charts/bar/#bar","title":"Bar","text":""},{"location":"_charts/bar/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.bar(df, x='keyword_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.bar(x='keyword_column', y='integer_column')\n</code></pre> </p>"},{"location":"_charts/bar/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.bar(\n    df, \n    x='keyword_column', \n    y='integer_column',\n    y2='float_column',\n    y2_style='dot',\n    horizontal=True,\n    bar_width='index',\n    group_other=True,\n    column_sort_order=\"desc\",\n    column_sort_type=\"string\",\n    pro_bar_mode=\"combined\",\n    combination_mode=\"max\",\n    show_bar_labels=True,\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.bar(\n    x='keyword_column', \n    y='integer_column',\n    y2='float_column',\n    y2_style='dot',\n    horizontal=True,\n    bar_width='index',\n    group_other=True,\n    column_sort_order=\"desc\",\n    column_sort_type=\"string\",\n    pro_bar_mode=\"combined\",\n    combination_mode=\"max\",\n    show_bar_labels=True,\n)\n</code></pre> </p>"},{"location":"_charts/bar/#bar_1","title":"Bar","text":""},{"location":"_charts/bar/#src.dx.plotting.dex.basic_charts.bar","title":"<code>src.dx.plotting.dex.basic_charts.bar(df, x, y, y2=None, y2_style='bar', horizontal=False, bar_width=None, group_other=False, column_sort_order='asc', column_sort_type='string', pro_bar_mode='combined', combination_mode='avg', show_bar_labels=False, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX bar plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>str</code> <p>The column(s) to use for the primary y-axis.</p> required <code>y2</code> <code>Optional[str]</code> <p>The column to use for the secondary y-axis.</p> <code>None</code> <code>y2_style</code> <code>DEXSecondMetricstyle</code> <p>The style to use for the secondary y-axis. (<code>\"bar\"</code> or <code>\"dot\"</code>)</p> <code>'bar'</code> <code>horizontal</code> <code>bool</code> <p>Whether to plot the bars horizontally.</p> <code>False</code> <code>bar_width</code> <code>Optional[str]</code> <p>The column to use for the bar width.</p> <code>None</code> <code>group_other</code> <code>bool</code> <p>Whether to group the remaining columns into an \"Other\" category.</p> <code>False</code> <code>column_sort_order</code> <code>DEXSortColumnsByOrder</code> <p>The order to sort the columns by (<code>\"asc\"</code> or <code>\"desc\"</code>)</p> <code>'asc'</code> <code>column_sort_type</code> <code>DEXSortColumnsByType</code> <p>The type of sorting to use. (<code>\"number\"</code>, <code>\"string\"</code>, or <code>\"date\"</code>)</p> <code>'string'</code> <code>pro_bar_mode</code> <code>DEXProBarModeType</code> <p>The bar mode to use (<code>\"clustered\"</code>, <code>\"combined\"</code>, or <code>\"stacked\"</code>).</p> <code>'combined'</code> <code>combination_mode</code> <code>DEXCombinationMode</code> <p>The combination mode to use (<code>\"avg\"</code>, <code>\"sum\"</code>, <code>\"min\"</code>, <code>\"median\"</code>, <code>\"max\"</code>, or <code>\"count\"</code>).</p> <code>'avg'</code> <code>show_bar_labels</code> <code>bool</code> <p>Whether to show the bar values as labels.</p> <code>False</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def bar(\n    df,\n    x: str,\n    y: str,\n    y2: Optional[str] = None,\n    y2_style: options.DEXSecondMetricstyle = \"bar\",\n    horizontal: bool = False,\n    bar_width: Optional[str] = None,\n    group_other: bool = False,\n    column_sort_order: options.DEXSortColumnsByOrder = \"asc\",\n    column_sort_type: options.DEXSortColumnsByType = \"string\",\n    pro_bar_mode: options.DEXProBarModeType = \"combined\",\n    combination_mode: options.DEXCombinationMode = \"avg\",\n    show_bar_labels: bool = False,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXBarChartView]:\n    \"\"\"\n    Generates a DEX bar plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: List[str]\n        The column(s) to use for the primary y-axis.\n    y2: Optional[str]\n        The column to use for the secondary y-axis.\n    y2_style: DEXSecondMetricstyle\n        The style to use for the secondary y-axis. (`\"bar\"` or `\"dot\"`)\n    horizontal: bool\n        Whether to plot the bars horizontally.\n    bar_width: Optional[str]\n        The column to use for the bar width.\n    group_other: bool\n        Whether to group the remaining columns into an \"Other\" category.\n    column_sort_order: DEXSortColumnsByOrder\n        The order to sort the columns by (`\"asc\"` or `\"desc\"`)\n    column_sort_type: DEXSortColumnsByType\n        The type of sorting to use. (`\"number\"`, `\"string\"`, or `\"date\"`)\n    pro_bar_mode: DEXProBarModeType\n        The bar mode to use (`\"clustered\"`, `\"combined\"`, or `\"stacked\"`).\n    combination_mode: DEXCombinationMode\n        The combination mode to use (`\"avg\"`, `\"sum\"`, `\"min\"`, `\"median\"`, `\"max\"`, or `\"count\"`).\n    show_bar_labels: bool\n        Whether to show the bar values as labels.\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns(x, df.columns)\n\n    if not isinstance(y, list):\n        y = [y]\n    raise_for_missing_columns(y, df.columns)\n    y1 = y[0]\n\n    chart_settings = {\n        \"dim1\": x,\n        \"metric1\": y1,\n        \"bar_projection\": \"horizontal\" if horizontal else \"vertical\",\n        \"sort_columns_by\": f\"{column_sort_order}-col-{column_sort_type}\",\n        \"group_other\": group_other,\n        \"combination_mode\": combination_mode,\n        \"bar_label\": \"show\" if show_bar_labels else \"none\",\n        \"selected_bar_metrics\": y,\n    }\n    if bar_width is not None:\n        chart_settings[\"metric3\"] = bar_width\n    if y2 is not None:\n        chart_settings[\"second_bar_metric\"] = y2\n        chart_settings[\"pro_bar_mode\"] = pro_bar_mode\n        chart_settings[\"second_metric_style\"] = y2_style\n\n    return handle_view(\n        df,\n        chart_mode=\"bar\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"_charts/big_number/","title":"Big number","text":""},{"location":"_charts/big_number/#big-number","title":"Big Number","text":"<p>Coming soon!</p>"},{"location":"_charts/big_number/#big-number_1","title":"Big Number","text":"<p>Coming soon!</p>"},{"location":"_charts/boxplot/","title":"Boxplot","text":""},{"location":"_charts/boxplot/#boxplot","title":"Boxplot","text":"<p>Coming soon!</p>"},{"location":"_charts/boxplot/#boxplot_1","title":"Boxplot","text":"<p>Coming soon!</p>"},{"location":"_charts/candlestick/","title":"Candlestick","text":""},{"location":"_charts/candlestick/#candlestick","title":"Candlestick","text":"<p>Coming soon!</p>"},{"location":"_charts/candlestick/#candlestick_1","title":"Candlestick","text":"<p>Coming soon!</p>"},{"location":"_charts/choropleth/","title":"Choropleth","text":""},{"location":"_charts/choropleth/#choropleth","title":"Choropleth","text":"<p>Coming soon!</p>"},{"location":"_charts/choropleth/#choropleth_1","title":"Choropleth","text":"<p>Coming soon!</p>"},{"location":"_charts/connected_scatterplot/","title":"Connected scatterplot","text":""},{"location":"_charts/connected_scatterplot/#connected-scatterplot","title":"Connected Scatterplot","text":"<p>Coming soon!</p>"},{"location":"_charts/connected_scatterplot/#connected-scatterplot_1","title":"Connected Scatterplot","text":"<p>Coming soon!</p>"},{"location":"_charts/correlation_matrix/","title":"Correlation matrix","text":""},{"location":"_charts/correlation_matrix/#correlation-matrix","title":"Correlation Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/correlation_matrix/#correlation-matrix_1","title":"Correlation Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/cumulative/","title":"Cumulative","text":""},{"location":"_charts/cumulative/#cumulative","title":"Cumulative","text":"<p>Coming soon!</p>"},{"location":"_charts/cumulative/#cumulative_1","title":"Cumulative","text":"<p>Coming soon!</p>"},{"location":"_charts/dashboards/","title":"Dashboards","text":"<p>Just like the plotting functions, generating dashboards with <code>dx</code> is very experimental and prone to change.</p>"},{"location":"_charts/dashboards/#making-a-dashboard","title":"Making a Dashboard","text":"<p>If you create charts using <code>dx</code> functions, you may want to combine them into a single view or dashboard. This can be done with <code>dashboard()</code>.</p> <p>Similar to the chart functions, <code>dashboard()</code> mainly requires a pandas DataFrame, as well as a list of views in a matrix-like orientation. (Each item in the list is treated as a row, and each row can be a list of views to specify column positioning.) </p>"},{"location":"_charts/dashboards/#simple","title":"Simple","text":"<p>Here's a quick example where we make a dashboard using two rows -- the top row will have scatter and bar charts, and the bottom will be our default grid view:</p> <p><pre><code>dx.dashboard(\n    df,\n    views=[\n        [\"scatter\", \"pie\"],\n        [\"grid\"],\n    ],\n)\n</code></pre> </p>"},{"location":"_charts/dashboards/#with-chart-views","title":"With Chart Views","text":"<p>Using chart functions, you can specify <code>return_view=True</code> and pass the resulting <code>DEXView</code> object into a dashboard.  <pre><code>custom_bar_chart = dx.bar(\n    df,\n    x='keyword_column',\n    y='integer_column',\n    column_sort_order='desc',\n    column_sort_type='string',\n    show_bar_labels=True,\n    return_view=True,\n)\n\nsimple_tilemap = dx.tilemap(\n    df,\n    lat='index',\n    lon='integer_column',\n    return_view=True,\n)\n\ndx.dashboard(\n    df,\n    views=[\n        [\"parallel_coordinates\", custom_bar_chart],\n        [simple_tilemap, 'pie', 'grid']\n    ]\n)\n</code></pre> </p>"},{"location":"_charts/dashboards/#customized","title":"Customized","text":"<p>If you want to provide some additional arguments, instead of passing a string to indicate the chart type, you can pass a dictionary with <code>{\"chart_mode\": CHART TYPE, **extra_kwargs}</code>. <pre><code>custom_chart = {\n    \"chart_mode\": \"hexbin\",\n    \"decoration\": {\n        \"title\": \"look at this sweet hexbin\"\n    },\n}\n\ndx.dashboard(\n    df, \n    views=[\n        [custom_chart, \"force_directed_network\"], \n        [\"ridgeline\"]\n    ]\n)\n</code></pre> </p>"},{"location":"_charts/dashboards/#making-a-dashboard_1","title":"Making a Dashboard","text":""},{"location":"_charts/dashboards/#src.dx.plotting.dashboards.dashboard","title":"<code>src.dx.plotting.dashboards.dashboard(df, views, **kwargs)</code>","text":"<p>Creates and renders a DEX dashboard from a list of views.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to be rendered.</p> required <code>views</code> <code>List[Union[str, dict, list, DEXView]]</code> <p>A list of views to be created and rendered in the dashboard. By default, each item in the list will be treated as a row item. Each item in the list can be another nested list of views to determine column positioning within the dashboard view.</p> required Source code in <code>src/dx/plotting/dashboards.py</code> <pre><code>def dashboard(\n    df: pd.DataFrame,\n    views: List[Union[str, dict, list, DEXView]],\n    **kwargs,\n) -&gt; Optional[DEXMetadata]:\n    \"\"\"\n    Creates and renders a DEX dashboard from a list of views.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The dataframe to be rendered.\n    views: List[Union[str, dict, list, DEXView]]\n        A list of views to be created and rendered in the dashboard.\n        By default, each item in the list will be treated as a row item.\n        Each item in the list can be another nested list of views to\n        determine column positioning within the dashboard view.\n    \"\"\"\n    dex_metadata = DEXMetadata()\n    multiview_order = []\n\n    # generate and add views, assuming a matrix-like structure\n    for row_num, views_row in enumerate(views):\n        if not isinstance(views_row, list):\n            views_row = [views_row]\n        for col_num, view in enumerate(views_row):\n            if isinstance(view, str):\n                # get the direct-to-chart option since we can't pass kwargs\n                view = dex.get_chart_view(df, f\"sample_{view.lower()}\")\n            elif isinstance(view, dict):\n                # view dict\n                dex_view = DEXView.parse_obj(view)\n            elif isinstance(view, DEXView):\n                dex_view = view\n            else:\n                raise ValueError(f\"Invalid view type: {type(view)}\")\n\n            # make the views available for reference\n            dex_dashboard_view = dex_view.copy(\n                update={\"is_default\": False, \"chartMode\": dex_view.chart_mode}\n            )\n            # TODO: make DEXMetadata.add_view() support adding DEXView\n            # instead of just dictionaries\n            dex_dashboard_view_dict = dex_dashboard_view.dict(\n                by_alias=True,\n                exclude_none=True,\n            )\n            logger.debug(f\"{dex_dashboard_view_dict=}\")\n            dex_metadata.views.append(dex_dashboard_view_dict)\n            # define the view positioning\n            multiview = {\n                \"column\": col_num,\n                \"row\": row_num,\n                \"id\": str(dex_dashboard_view.id),\n            }\n            multiview_order.append(multiview)\n\n    dashboard_view_metadata = {\n        \"views\": multiview_order,\n        \"isDefault\": True,\n        \"decoration\": {\n            \"title\": \"\ud83e\udd14 dx dashboard\",\n        },\n    }\n    dashboard_view_metadata.update(kwargs)\n\n    dex_dashboard_metadata = DEXView.parse_obj(dashboard_view_metadata)\n\n    with settings_context(generate_dex_metadata=True):\n        handle_format(\n            df,\n            extra_metadata={\n                \"dashboard\": {\n                    \"multiViews\": [\n                        dex_dashboard_metadata.dict(by_alias=True),\n                    ],\n                },\n                \"views\": dex_metadata.views,\n            },\n        )\n</code></pre>"},{"location":"_charts/dataprism/","title":"Dataprism","text":""},{"location":"_charts/dataprism/#chart-name","title":"Chart Name","text":"<p>Coming soon!</p>"},{"location":"_charts/dataprism/#chart-name_1","title":"Chart Name","text":"<p>Coming soon!</p>"},{"location":"_charts/dendrogram/","title":"Dendrogram","text":""},{"location":"_charts/dendrogram/#dendrogram","title":"Dendrogram","text":"<p>Coming soon!</p>"},{"location":"_charts/dendrogram/#dendrogram_1","title":"Dendrogram","text":"<p>Coming soon!</p>"},{"location":"_charts/dimension_matrix/","title":"Dimension matrix","text":""},{"location":"_charts/dimension_matrix/#dimension-matrix","title":"Dimension Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/dimension_matrix/#dimension-matrix_1","title":"Dimension Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/diverging_bar/","title":"Diverging bar","text":""},{"location":"_charts/diverging_bar/#diverging-bar","title":"Diverging Bar","text":"<p>Coming soon!</p>"},{"location":"_charts/diverging_bar/#diverging-bar_1","title":"Diverging Bar","text":"<p>Coming soon!</p>"},{"location":"_charts/donut/","title":"Donut","text":""},{"location":"_charts/donut/#donut","title":"Donut","text":"<p>Coming soon!</p>"},{"location":"_charts/donut/#donut_1","title":"Donut","text":"<p>Coming soon!</p>"},{"location":"_charts/dotplot/","title":"Dotplot","text":""},{"location":"_charts/dotplot/#dot-plot","title":"Dot Plot","text":"<p>Coming soon!</p>"},{"location":"_charts/dotplot/#dot-plot_1","title":"Dot Plot","text":"<p>Coming soon!</p>"},{"location":"_charts/flow_diagram/","title":"Flow diagram","text":""},{"location":"_charts/flow_diagram/#flow-diagram","title":"Flow Diagram","text":"<p>Coming soon!</p>"},{"location":"_charts/flow_diagram/#flow-diagram_1","title":"Flow Diagram","text":"<p>Coming soon!</p>"},{"location":"_charts/force_directed_network/","title":"Force directed network","text":""},{"location":"_charts/force_directed_network/#force-directed-network","title":"Force-directed Network","text":"<p>Coming soon!</p>"},{"location":"_charts/force_directed_network/#force-directed-network_1","title":"Force-directed Network","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel/","title":"Funnel","text":""},{"location":"_charts/funnel/#funnel","title":"Funnel","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel/#funnel_1","title":"Funnel","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel_chart/","title":"Funnel chart","text":""},{"location":"_charts/funnel_chart/#funnel-chart","title":"Funnel Chart","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel_chart/#funnel-chart_1","title":"Funnel Chart","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel_sunburst/","title":"Funnel sunburst","text":""},{"location":"_charts/funnel_sunburst/#funnel-sunburst","title":"Funnel Sunburst","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel_sunburst/#funnel-sunburst_1","title":"Funnel Sunburst","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel_tree/","title":"Funnel tree","text":""},{"location":"_charts/funnel_tree/#funnel-tree","title":"Funnel Tree","text":"<p>Coming soon!</p>"},{"location":"_charts/funnel_tree/#funnel-tree_1","title":"Funnel Tree","text":"<p>Coming soon!</p>"},{"location":"_charts/heatmap/","title":"Heatmap","text":""},{"location":"_charts/heatmap/#heatmap","title":"Heatmap","text":"<p>Coming soon!</p>"},{"location":"_charts/heatmap/#heatmap_1","title":"Heatmap","text":"<p>Coming soon!</p>"},{"location":"_charts/hexbin/","title":"Hexbin","text":""},{"location":"_charts/hexbin/#hexbin","title":"Hexbin","text":"<p>Coming soon!</p>"},{"location":"_charts/hexbin/#hexbin_1","title":"Hexbin","text":"<p>Coming soon!</p>"},{"location":"_charts/histogram/","title":"Histogram","text":""},{"location":"_charts/histogram/#histogram","title":"Histogram","text":"<p>Coming soon!</p>"},{"location":"_charts/histogram/#histogram_1","title":"Histogram","text":"<p>Coming soon!</p>"},{"location":"_charts/horizon/","title":"Horizon","text":""},{"location":"_charts/horizon/#horizon","title":"Horizon","text":"<p>Coming soon!</p>"},{"location":"_charts/horizon/#horizon_1","title":"Horizon","text":"<p>Coming soon!</p>"},{"location":"_charts/line/","title":"Line","text":""},{"location":"_charts/line/#line","title":"Line","text":""},{"location":"_charts/line/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.line(df, x='datetime_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.line(x='datetime_column', y='integer_column')\n</code></pre> </p>"},{"location":"_charts/line/#customized","title":"Customized","text":"<p>You may need to use a larger dataset to see the changes here. For these examples, we used <code>dx.random_dataframe(5000)</code>.</p> dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.line(\n    df, \n    x='datetime_column', \n    y='integer_column',\n    line_type=\"cumulative\",\n    split_by=\"keyword_column\",\n    multi_axis=True,\n    smoothing=\"hourly\",\n    use_count=True,\n    bounding_type=\"relative\",\n    zero_baseline=True,\n    combination_mode=\"min\",\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.line(\n    x='datetime_column', \n    y='integer_column',\n    line_type=\"cumulative\",\n    split_by=\"keyword_column\",\n    multi_axis=True,\n    smoothing=\"hourly\",\n    use_count=True,\n    bounding_type=\"relative\",\n    zero_baseline=True,\n    combination_mode=\"min\",\n)\n</code></pre> </p>"},{"location":"_charts/line/#line_1","title":"Line","text":""},{"location":"_charts/line/#src.dx.plotting.dex.basic_charts.line","title":"<code>src.dx.plotting.dex.basic_charts.line(df, x, y, line_type='line', split_by=None, multi_axis=False, smoothing=None, use_count=False, bounding_type='absolute', zero_baseline=False, combination_mode='avg', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX line plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>Union[List[str], str]</code> <p>The column(s) to use for the y-axis.</p> required <code>line_type</code> <code>DEXLineType</code> <p>The line type to use:     - <code>\"bumparea\"</code>     - <code>\"cumulative\"</code>     - <code>\"line\"</code> (default)     - <code>\"linepercent\"</code>     - <code>\"stackedarea\"</code>     - <code>\"stackedpercent\"</code></p> <code>'line'</code> <code>split_by</code> <code>Optional[str]</code> <p>The column to use for splitting the lines.</p> <code>None</code> <code>multi_axis</code> <code>bool</code> <p>Whether to use multiple y-axes.</p> <code>False</code> <code>smoothing</code> <code>Optional[DEXLineSmoothing]</code> <p>The line smoothing to use:     - <code>None</code> (default)     - <code>\"hourly\"</code>     - <code>\"daily\"</code>     - <code>\"weekly\"</code>     - <code>\"seven_day_moving_average\"</code>     - <code>\"monthly\"</code></p> <code>None</code> <code>use_count</code> <code>bool</code> <p>Whether to use the DEX_COUNT column for the y-axis.</p> <code>False</code> <code>bounding_type</code> <code>DEXBoundingType</code> <p>The bounding type to use:     - <code>\"absolute\"</code> (default)     - <code>\"relative\"</code></p> <code>'absolute'</code> <code>zero_baseline</code> <code>bool</code> <p>Whether to use a zero base line.</p> <code>False</code> <code>combination_mode</code> <code>DEXCombinationMode</code> <p>The combination mode to use (<code>\"avg\"</code>, <code>\"sum\"</code>, <code>\"min\"</code>, <code>\"median\"</code>, <code>\"max\"</code>, or <code>\"count\"</code>).</p> <code>'avg'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def line(\n    df,\n    x: str,\n    y: Union[List[str], str],\n    line_type: options.DEXLineType = \"line\",\n    split_by: Optional[str] = None,\n    multi_axis: bool = False,\n    smoothing: Optional[options.DEXLineSmoothing] = None,\n    use_count: bool = False,\n    bounding_type: options.DEXBoundingType = \"absolute\",\n    zero_baseline: bool = False,\n    combination_mode: options.DEXCombinationMode = \"avg\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXLineChartView]:\n    \"\"\"\n    Generates a DEX line plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: Union[List[str], str]\n        The column(s) to use for the y-axis.\n    line_type: DEXLineType\n        The line type to use:\n            - `\"bumparea\"`\n            - `\"cumulative\"`\n            - `\"line\"` (default)\n            - `\"linepercent\"`\n            - `\"stackedarea\"`\n            - `\"stackedpercent\"`\n    split_by: Optional[str]\n        The column to use for splitting the lines.\n    multi_axis: bool\n        Whether to use multiple y-axes.\n    smoothing: Optional[DEXLineSmoothing]\n        The line smoothing to use:\n            - `None` (default)\n            - `\"hourly\"`\n            - `\"daily\"`\n            - `\"weekly\"`\n            - `\"seven_day_moving_average\"`\n            - `\"monthly\"`\n    use_count: bool\n        Whether to use the DEX_COUNT column for the y-axis.\n    bounding_type: DEXBoundingType\n        The bounding type to use:\n            - `\"absolute\"` (default)\n            - `\"relative\"`\n    zero_baseline: bool\n        Whether to use a zero base line.\n    combination_mode: DEXCombinationMode\n        The combination mode to use (`\"avg\"`, `\"sum\"`, `\"min\"`, `\"median\"`, `\"max\"`, or `\"count\"`).\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns(x, df.columns)\n\n    if isinstance(y, str):\n        y = [y]\n    raise_for_missing_columns(y, df.columns)\n    if use_count:\n        y.append(\"DEX_COUNT\")\n\n    if split_by is not None:\n        if str(split_by) not in df.columns:\n            raise ValueError(f\"Column '{split_by}' not found in DataFrame.\")\n\n    chart_settings = {\n        \"bounding_type\": bounding_type,\n        \"combination_mode\": combination_mode,\n        \"line_smoothing\": smoothing or \"none\",\n        \"line_type\": line_type,\n        \"multi_axis_line\": multi_axis,\n        \"selected_metrics\": y,\n        \"split_lines_by\": split_by,\n        \"timeseries_sort\": x,\n        \"zero_baseline\": zero_baseline,\n    }\n    logger.debug(f\"{chart_settings=}\")\n    return handle_view(\n        df,\n        chart_mode=\"line\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"_charts/line_percent/","title":"Line percent","text":""},{"location":"_charts/line_percent/#line-percent","title":"Line Percent","text":"<p>Coming soon!</p>"},{"location":"_charts/line_percent/#line-percent_1","title":"Line Percent","text":"<p>Coming soon!</p>"},{"location":"_charts/parallel_coordinates/","title":"Parallel coordinates","text":""},{"location":"_charts/parallel_coordinates/#parallel-coordinates","title":"Parallel Coordinates","text":"<p>Coming soon!</p>"},{"location":"_charts/parallel_coordinates/#parallel-coordinates_1","title":"Parallel Coordinates","text":"<p>Coming soon!</p>"},{"location":"_charts/partition/","title":"Partition","text":""},{"location":"_charts/partition/#partition","title":"Partition","text":"<p>Coming soon!</p>"},{"location":"_charts/partition/#partition_1","title":"Partition","text":"<p>Coming soon!</p>"},{"location":"_charts/pie/","title":"Pie","text":""},{"location":"_charts/pie/#pie","title":"Pie","text":""},{"location":"_charts/pie/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.pie(df, y='index')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.pie(y='index')\n</code></pre> </p>"},{"location":"_charts/pie/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.pie(\n    df, \n    y='index',\n    split_slices_by='keyword_column',\n    show_total=False,\n    pie_label_type='annotation',\n    pie_label_contents='percent',\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.pie(\n    y='index',\n    split_slices_by='keyword_column',\n    show_total=False,\n    pie_label_type='annotation',\n    pie_label_contents='percent',\n)\n</code></pre> </p>"},{"location":"_charts/pie/#pie_1","title":"Pie","text":""},{"location":"_charts/pie/#src.dx.plotting.dex.basic_charts.pie","title":"<code>src.dx.plotting.dex.basic_charts.pie(df, y, split_slices_by=None, show_total=True, pie_label_type='rim', pie_label_contents='name', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX pie plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>y</code> <code>str</code> <p>The column to use for the slice size.</p> required <code>split_slices_by</code> <code>Optional[str]</code> <p>The column to use for splitting the slices. If not provided, slices will be split and sized by <code>y</code>.</p> <code>None</code> <code>show_total</code> <code>bool</code> <p>Whether to show the total.</p> <code>True</code> <code>pie_label_type</code> <code>DEXPieLabelType</code> <p>The pie label type to use:     - <code>\"rim\"</code> (default)     - <code>\"annotation\"</code>     - <code>\"center\"</code>     - <code>\"stem\"</code>     - <code>\"none\"</code></p> <code>'rim'</code> <code>pie_label_contents</code> <code>DEXPieLabelContents</code> <p>The pie label contents to use:     - <code>\"name\"</code> (default)     - <code>\"value\"</code>     - <code>\"percent\"</code>     - <code>\"name_value\"</code>     - <code>\"name_percent\"</code>     - <code>\"value_percent\"</code></p> <code>'name'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def pie(\n    df,\n    y: str,\n    split_slices_by: Optional[str] = None,\n    show_total: bool = True,\n    pie_label_type: options.DEXPieLabelType = \"rim\",\n    pie_label_contents: options.DEXPieLabelContents = \"name\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXPieChartView]:\n    \"\"\"\n    Generates a DEX pie plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    y: str\n        The column to use for the slice size.\n    split_slices_by: Optional[str]\n        The column to use for splitting the slices. If not provided, slices will be split and sized by `y`.\n    show_total: bool\n        Whether to show the total.\n    pie_label_type: DEXPieLabelType\n        The pie label type to use:\n            - `\"rim\"` (default)\n            - `\"annotation\"`\n            - `\"center\"`\n            - `\"stem\"`\n            - `\"none\"`\n    pie_label_contents: DEXPieLabelContents\n        The pie label contents to use:\n            - `\"name\"` (default)\n            - `\"value\"`\n            - `\"percent\"`\n            - `\"name_value\"`\n            - `\"name_percent\"`\n            - `\"value_percent\"`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    if split_slices_by is None:\n        split_slices_by = y\n    raise_for_missing_columns([y, split_slices_by], df.columns)\n\n    chart_settings = {\n        \"dim1\": split_slices_by,\n        \"metric1\": y,\n        \"show_total\": show_total,\n        \"pie_label_type\": pie_label_type,\n        \"pie_label_contents\": pie_label_contents,\n    }\n    return handle_view(\n        df,\n        chart_mode=\"pie\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"_charts/radar_plot/","title":"Radar plot","text":""},{"location":"_charts/radar_plot/#radar-plot","title":"Radar Plot","text":"<p>Coming soon!</p>"},{"location":"_charts/radar_plot/#radar-plot_1","title":"Radar Plot","text":"<p>Coming soon!</p>"},{"location":"_charts/ridgeline/","title":"Ridgeline","text":""},{"location":"_charts/ridgeline/#ridgeline","title":"Ridgeline","text":"<p>Coming soon!</p>"},{"location":"_charts/ridgeline/#ridgeline_1","title":"Ridgeline","text":"<p>Coming soon!</p>"},{"location":"_charts/sankey/","title":"Sankey","text":""},{"location":"_charts/sankey/#sankey","title":"Sankey","text":"<p>Coming soon!</p>"},{"location":"_charts/sankey/#sankey_1","title":"Sankey","text":"<p>Coming soon!</p>"},{"location":"_charts/scatter/","title":"Scatter","text":""},{"location":"_charts/scatter/#scatter","title":"Scatter","text":""},{"location":"_charts/scatter/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.scatter(df, x='float_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p>Known Issue</p> <p><code>df.plot.scatter()</code> can be used unless <code>size</code> is specified. If you wish to use pandas syntax and provide a <code>size</code> argument, please use <code>df.plot(kind='scatter', ...)</code>.</p> <p><pre><code>df.plot(kind='scatter', x='float_column', y='integer_column')\n</code></pre> </p>"},{"location":"_charts/scatter/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.scatter(\n    df, \n    x='float_column', \n    y='integer_column',\n    size='index',\n    trend_line='polynomial',\n    marginal_graphics='histogram',\n    formula_display='r2'\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p>Known Issue</p> <p><code>df.plot.scatter()</code> can be used unless <code>size</code> is specified. If you wish to use pandas syntax and provide a <code>size</code> argument, please use <code>df.plot(kind='scatter', ...)</code>.</p> <p><pre><code>df.plot(\n    kind='scatter',\n    x='float_column', \n    y='integer_column',\n    size='index',\n    trend_line='polynomial',\n    marginal_graphics='histogram',\n    formula_display='r2'\n)\n</code></pre> </p>"},{"location":"_charts/scatter/#scatter_1","title":"Scatter","text":""},{"location":"_charts/scatter/#src.dx.plotting.dex.basic_charts.scatter","title":"<code>src.dx.plotting.dex.basic_charts.scatter(df, x, y, size=None, trend_line=None, marginal_graphics=None, formula_display=None, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX scatterplot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>str</code> <p>The column to use for the y-axis.</p> required <code>size</code> <code>Optional[str]</code> <p>The column to use for sizing scatterplot points.</p> <code>None</code> <code>trend_line</code> <code>Optional[DEXTrendlineType]</code> <p>The type of trendline to use. One of <code>\"linear\"</code>, <code>\"exponential\"</code>, <code>\"polynomial\"</code>, <code>\"power\"</code>, or <code>\"logarithmic\"</code>.</p> <code>None</code> <code>marginal_graphics</code> <code>Optional[DEXSummaryType]</code> <p>The marginal graphics to use:     - <code>boxplot</code>     - <code>heatmap</code>     - <code>histogram</code>     - <code>horizon</code>     - <code>joy</code>     - <code>ridgeline</code>     - <code>violin</code></p> <code>None</code> <code>formula_display</code> <code>Optional[DEXFormulaDisplay]</code> <p>The formula display to use:     - <code>r2</code>     - <code>formula</code></p> <code>None</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def scatter(\n    df: pd.DataFrame,\n    x: str,\n    y: str,\n    size: Optional[str] = None,\n    trend_line: Optional[options.DEXTrendlineType] = None,\n    marginal_graphics: Optional[options.DEXSummaryType] = None,\n    formula_display: Optional[options.DEXFormulaDisplay] = None,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXScatterChartView]:\n    \"\"\"\n    Generates a DEX scatterplot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: str\n        The column to use for the y-axis.\n    size: Optional[str]\n        The column to use for sizing scatterplot points.\n    trend_line: Optional[DEXTrendlineType]\n        The type of trendline to use. One of `\"linear\"`, `\"exponential\"`, `\"polynomial\"`, `\"power\"`, or `\"logarithmic\"`.\n    marginal_graphics: Optional[DEXSummaryType]\n        The marginal graphics to use:\n            - `boxplot`\n            - `heatmap`\n            - `histogram`\n            - `horizon`\n            - `joy`\n            - `ridgeline`\n            - `violin`\n    formula_display: Optional[DEXFormulaDisplay]\n        The formula display to use:\n            - `r2`\n            - `formula`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([x, y], df.columns)\n\n    chart_settings = {\n        \"metric1\": x,\n        \"metric2\": y,\n    }\n    # if these are present but set to `None`, DEX gets angry\n    if trend_line is not None:\n        chart_settings[\"trendLine\"] = trend_line\n    if size is not None:\n        chart_settings[\"scatterplotSize\"] = size\n    if marginal_graphics is not None:\n        chart_settings[\"marginalGraphics\"] = marginal_graphics\n    if formula_display is not None:\n        chart_settings[\"formulaDisplay\"] = formula_display\n\n    return handle_view(\n        df,\n        chart_mode=\"scatter\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"_charts/scatterplot_matrix/","title":"Scatterplot matrix","text":""},{"location":"_charts/scatterplot_matrix/#scatterplot-matrix","title":"Scatterplot Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/scatterplot_matrix/#scatterplot-matrix_1","title":"Scatterplot Matrix","text":"<p>Coming soon!</p>"},{"location":"_charts/stacked_area/","title":"Stacked area","text":""},{"location":"_charts/stacked_area/#stacked-area","title":"Stacked Area","text":"<p>Coming soon!</p>"},{"location":"_charts/stacked_area/#stacked-area_1","title":"Stacked Area","text":"<p>Coming soon!</p>"},{"location":"_charts/stacked_percent/","title":"Stacked percent","text":""},{"location":"_charts/stacked_percent/#stacked-percent","title":"Stacked Percent","text":"<p>Coming soon!</p>"},{"location":"_charts/stacked_percent/#stacked-percent_1","title":"Stacked Percent","text":"<p>Coming soon!</p>"},{"location":"_charts/sunburst/","title":"Sunburst","text":""},{"location":"_charts/sunburst/#sunburst","title":"Sunburst","text":"<p>Coming soon!</p>"},{"location":"_charts/sunburst/#sunburst_1","title":"Sunburst","text":"<p>Coming soon!</p>"},{"location":"_charts/tilemap/","title":"Tilemap","text":""},{"location":"_charts/tilemap/#tilemap","title":"Tilemap","text":"<p>Since <code>dx.random_dataframe()</code> returns <code>integer_column</code> values (<code>-100</code> to <code>100</code>) and <code>float_column</code> values (<code>0.0</code> to <code>1.0</code>) as the only numeric columns by default, we can suggest enabling the <code>lat_float_column</code> and <code>lon_float_column</code> arguments for some quick testing: <pre><code>df = dx.random_dataframe(100, lat_float_column=True, lon_float_column=True)\n</code></pre></p> <p>More about how Noteable builds with Mapbox here. \ud83d\uddfa\ufe0f</p>"},{"location":"_charts/tilemap/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.tilemap(df, lon='lon_float_column', lat='lat_float_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='tilemap', lon='lon_float_column', lat='lat_float_column')\n</code></pre> *Note you can't use <code>df.plot.tilemap()</code> directly</p> <p></p>"},{"location":"_charts/tilemap/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.tilemap(\n    df,\n    lat='lat_float_column',\n    lon='lon_float_column',\n    icon_opacity=0.5,\n    icon_size='index',\n    icon_size_scale=\"log\",\n    stroke_color=\"magenta\",\n    stroke_width=5,\n    label_column='bytes_column',\n    tile_layer=\"light\",\n    hover_cols=['keyword_column', 'datetime_column'],\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='tilemap',\n    lat='lat_float_column',\n    lon='lon_float_column',\n    icon_opacity=0.5,\n    icon_size='index',\n    icon_size_scale=\"log\",\n    stroke_color=\"magenta\",\n    stroke_width=5,\n    label_column='bytes_column',\n    tile_layer=\"light\",\n    hover_cols=['keyword_column', 'datetime_column'],\n)\n</code></pre> *Note you can't use <code>df.plot.tilemap()</code> directly</p> <p></p>"},{"location":"_charts/tilemap/#tilemap_1","title":"Tilemap","text":""},{"location":"_charts/tilemap/#src.dx.plotting.dex.map_charts.tilemap","title":"<code>src.dx.plotting.dex.map_charts.tilemap(df, lat, lon, icon_opacity=1.0, icon_size=2, icon_size_scale='linear', stroke_color='#000000', stroke_width=2, label_column=None, tile_layer='streets', hover_cols=None, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX tilemap from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>lat</code> <code>str</code> <p>The column to use for the latitude values.</p> required <code>lon</code> <code>str</code> <p>The column to use for the longitude values.</p> required <code>icon_opacity</code> <code>float</code> <p>The opacity to use for the icon (<code>0.0</code> to <code>1.0</code>)</p> <code>1.0</code> <code>icon_size</code> <code>int</code> <p>Either: - int: a fixed size to use for the icon (<code>0</code> to <code>10</code>) - str: a column name to use for functional sizing</p> <code>2</code> <code>icon_size_scale</code> <code>DEXScale</code> <p>The scale to use for functional sizing (<code>\"linear\"</code> or <code>\"log\"</code>)</p> <code>'linear'</code> <code>stroke_color</code> <code>Color</code> <p>The color to use for the icon stroke.</p> <code>'#000000'</code> <code>stroke_width</code> <code>int</code> <p>The width to use for the icon stroke.</p> <code>2</code> <code>tile_layer</code> <code>str</code> <p>The type of tile layer to use. One of <code>\"streets\"</code>, <code>\"outdoors\"</code>, <code>\"light\"</code>, <code>\"dark\"</code>, or <code>\"satellite\"</code></p> <code>'streets'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/map_charts.py</code> <pre><code>def tilemap(\n    df,\n    lat: str,\n    lon: str,\n    icon_opacity: float = 1.0,\n    icon_size: int = 2,\n    icon_size_scale: options.DEXScale = \"linear\",\n    stroke_color: Color = \"#000000\",\n    stroke_width: int = 2,\n    label_column: Optional[str] = None,\n    tile_layer: str = \"streets\",\n    hover_cols: Optional[List[str]] = None,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXTilemapChartView]:\n    \"\"\"\n    Generates a DEX tilemap from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    lat: str\n        The column to use for the latitude values.\n    lon: str\n        The column to use for the longitude values.\n    icon_opacity: float\n        The opacity to use for the icon (`0.0` to `1.0`)\n    icon_size: Union[int, str]\n        Either:\n        - int: a fixed size to use for the icon (`0` to `10`)\n        - str: a column name to use for functional sizing\n    icon_size_scale: DEXScale\n        The scale to use for functional sizing (`\"linear\"` or `\"log\"`)\n    stroke_color: Color\n        The color to use for the icon stroke.\n    stroke_width: int\n        The width to use for the icon stroke.\n    tile_layer: str\n        The type of tile layer to use. One of `\"streets\"`, `\"outdoors\"`, `\"light\"`, `\"dark\"`, or `\"satellite\"`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([lat, lon], df.columns)\n\n    if isinstance(hover_cols, str):\n        hover_cols = [hover_cols]\n    if hover_cols is None:\n        hover_cols = df.columns\n    else:\n        raise_for_missing_columns(hover_cols, df.columns)\n\n    if label_column is not None:\n        raise_for_missing_columns(label_column, df.columns)\n\n    if isinstance(icon_size, str):\n        # referencing a column, treat as functional sizing\n\n        if icon_size not in df.columns:\n            # \"index\" was chosen but isn't in columns, which passes raise_for_missing_columns()\n            series = df.index\n        else:\n            series = df[icon_size]\n\n        series_min = series.min()\n        if str(icon_size_scale).lower() == \"log\":\n            series_min = 1\n\n        point_size_opts = {\n            \"mode\": \"functional\",\n            \"size\": 2,\n            \"met\": icon_size,\n            \"scale\": icon_size_scale,\n            \"min\": series_min,\n            \"max\": series.max(),\n            \"sizeMin\": 1,\n            \"sizeMax\": 10,\n        }\n    elif isinstance(icon_size, int):\n        # fixed sizing, shouldn't matter what we put in here\n        point_size_opts = {\n            \"mode\": \"fixed\",\n            \"size\": icon_size,\n            \"met\": str(lon),\n            \"scale\": icon_size_scale,\n            \"min\": df[str(lon)].min(),\n            \"max\": df[str(lon)].max(),\n            \"sizeMin\": 1,\n            \"sizeMax\": 10,\n        }\n    else:\n        raise ValueError(f\"`{type(icon_size)}` is not a valid type for `icon_size`.\")\n\n    # determine which columns are numeric and which ones are strings/mixed/etc\n    dimension_cols = [col for col in hover_cols if df[col].dtype == \"object\"]\n    metric_cols = [col for col in hover_cols if col not in dimension_cols]\n\n    layer_settings = {\n        \"lat_dim\": lat,\n        \"long_dim\": lon,\n        \"transparency\": icon_opacity,\n        \"size\": icon_size,\n        \"type\": \"point\",\n        \"stroke\": stroke_color,\n        \"stroke_width\": stroke_width,\n        \"point_size_opts\": point_size_opts,\n        \"hover_opts\": {\n            \"dims\": dimension_cols,\n            \"mets\": metric_cols,\n        },\n        \"tile_layer\": tile_layer,\n    }\n    if label_column is not None:\n        layer_settings[\"show_labels\"] = label_column\n\n    chart_settings = {\n        \"map_mode\": \"tile\",\n        \"layer_settings\": [layer_settings],\n    }\n    return handle_view(\n        df,\n        chart_mode=\"tilemap\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"_charts/treemap/","title":"Treemap","text":""},{"location":"_charts/treemap/#treemap","title":"Treemap","text":"<p>Coming soon!</p>"},{"location":"_charts/treemap/#treemap_1","title":"Treemap","text":"<p>Coming soon!</p>"},{"location":"_charts/violin/","title":"Violin","text":""},{"location":"_charts/violin/#violin","title":"Violin","text":""},{"location":"_charts/violin/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.violin(df, split_by='keyword_column', metric='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='violin', split_by='keyword_column', metric='integer_column')\n</code></pre> *Note you can't use <code>df.plot.violin()</code> directly</p> <p></p>"},{"location":"_charts/violin/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.violin(\n    df, \n    split_by='keyword_column', \n    metric='integer_column',\n    bins=5,\n    show_interquartile_range=True,\n    column_sort_order='desc',\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='violin',\n    split_by='keyword_column', \n    metric='integer_column',\n    bins=5,\n    show_interquartile_range=True,\n    column_sort_order='desc',\n)\n</code></pre> *Note you can't use <code>df.plot.violin()</code> directly</p> <p></p>"},{"location":"_charts/violin/#violin_1","title":"Violin","text":""},{"location":"_charts/violin/#src.dx.plotting.dex.summary_charts.violin","title":"<code>src.dx.plotting.dex.summary_charts.violin(df, split_by, metric, bins=30, show_interquartile_range=False, column_sort_order='asc', column_sort_type='string', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX violin plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>split_by</code> <code>str</code> <p>The column to use for splitting the data.</p> required <code>metric</code> <code>str</code> <p>The column to use to show distribution and density.</p> required <code>bins</code> <code>int</code> <p>The number of bins to use for the violin plot.</p> <code>30</code> <code>show_interquartile_range</code> <code>bool</code> <p>Whether to show the interquartile range.</p> <code>False</code> <code>column_sort_order</code> <code>DEXSortColumnsByOrder</code> <p>The order to sort the columns by. (<code>\"asc\"</code> or <code>\"desc\"</code>)</p> <code>'asc'</code> <code>column_sort_type</code> <code>DEXSortColumnsByType</code> <p>The type of sorting to use. (<code>\"number\"</code>, <code>\"string\"</code>, or <code>\"date\"</code>)</p> <code>'string'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/summary_charts.py</code> <pre><code>def violin(\n    df: pd.DataFrame,\n    split_by: str,\n    metric: str,\n    bins: int = 30,\n    show_interquartile_range: bool = False,\n    column_sort_order: options.DEXSortColumnsByOrder = \"asc\",\n    column_sort_type: options.DEXSortColumnsByType = \"string\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXViolinChartView]:\n    \"\"\"\n    Generates a DEX violin plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    split_by: str\n        The column to use for splitting the data.\n    metric: str\n        The column to use to show distribution and density.\n    bins: int\n        The number of bins to use for the violin plot.\n    show_interquartile_range: bool\n        Whether to show the interquartile range.\n    column_sort_order: DEXSortColumnsByOrder\n        The order to sort the columns by. (`\"asc\"` or `\"desc\"`)\n    column_sort_type: DEXSortColumnsByType\n        The type of sorting to use. (`\"number\"`, `\"string\"`, or `\"date\"`)\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    if str(column_sort_order).lower() == \"asc\":\n        sort_order = \"desc\"\n    elif str(column_sort_order).lower() == \"desc\":\n        sort_order = \"asc\"\n    chart_params = dict(\n        summary_bins=bins,\n        sort_columns_by=f\"{sort_order}-col-{column_sort_type}\",\n        violin_iqr=show_interquartile_range,\n    )\n    return summary(\n        df,\n        split_by=split_by,\n        metric=metric,\n        summary_type=\"violin\",\n        chart_params=chart_params,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"_charts/wordcloud/","title":"Wordcloud","text":""},{"location":"_charts/wordcloud/#wordcloud","title":"Wordcloud","text":""},{"location":"_charts/wordcloud/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.wordcloud(df, word_column='keyword_column', size='float_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='wordcloud', word_column='keyword_column', size='float_column')\n</code></pre> *Note you can't use <code>df.plot.wordcloud()</code> directly</p> <p></p>"},{"location":"_charts/wordcloud/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.wordcloud(\n    df, \n    word_column='dtype_column',\n    size='float_column',\n    text_format='token',\n    word_rotation='45',\n    random_coloring=True,\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='wordcloud',\n    word_column='keyword_column',\n    word_column='dtype_column',\n    size='float_column',\n    text_format='token',\n    word_rotation='45',\n    random_coloring=True,\n)\n</code></pre> *Note you can't use <code>df.plot.wordcloud()</code> directly</p> <p></p>"},{"location":"_charts/wordcloud/#wordcloud_1","title":"Wordcloud","text":""},{"location":"_charts/wordcloud/#src.dx.plotting.dex.basic_charts.wordcloud","title":"<code>src.dx.plotting.dex.basic_charts.wordcloud(df, word_column, size, text_format='sentence', word_rotation=None, random_coloring=False, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX wordcloud from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>word_column</code> <code>str</code> <p>The column to use for the words in the cloud.</p> required <code>size</code> <code>str</code> <p>The column to use for the size of the words in the cloud.</p> required <code>text_format</code> <code>DEXTextDataFormat</code> <p>The format of the text data. Either <code>\"sentence\"</code> or <code>\"token\"</code>.</p> <code>'sentence'</code> <code>word_rotation</code> <code>Optional[DEXWordRotate]</code> <p>The rotation to use for the words in the cloud (<code>45</code>, <code>90</code>, <code>\"jitter\"</code>, or <code>None</code>).</p> <code>None</code> <code>random_coloring</code> <code>bool</code> <p>Whether to use random coloring for the words in the cloud.</p> <code>False</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def wordcloud(\n    df: pd.DataFrame,\n    word_column: str,\n    size: str,\n    text_format: options.DEXTextDataFormat = \"sentence\",\n    word_rotation: Optional[options.DEXWordRotate] = None,\n    random_coloring: bool = False,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXWordcloudChartView]:\n    \"\"\"\n    Generates a DEX wordcloud from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    word_column: str\n        The column to use for the words in the cloud.\n    size: str\n        The column to use for the size of the words in the cloud.\n    text_format: DEXTextDataFormat\n        The format of the text data. Either `\"sentence\"` or `\"token\"`.\n    word_rotation: Optional[DEXWordRotate]\n        The rotation to use for the words in the cloud (`45`, `90`, `\"jitter\"`, or `None`).\n    random_coloring: bool\n        Whether to use random coloring for the words in the cloud.\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([word_column, size], df.columns)\n\n    chart_settings = {\n        \"text_data_format\": text_format,\n        \"token_metric\": size,\n        \"word_data\": word_column,\n        \"word_color\": \"random\" if random_coloring else \"none\",\n        \"word_rotate\": word_rotation if word_rotation else \"none\",\n    }\n    return handle_view(\n        df,\n        chart_mode=\"wordcloud\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"plotting/basic_charts/","title":"Basic Charts","text":"<p>Here we'll talk about how to plot some basic chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/basic_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/basic_charts/#bar","title":"Bar","text":""},{"location":"plotting/basic_charts/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.bar(df, x='keyword_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.bar(x='keyword_column', y='integer_column')\n</code></pre> </p>"},{"location":"plotting/basic_charts/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.bar(\n    df, \n    x='keyword_column', \n    y='integer_column',\n    y2='float_column',\n    y2_style='dot',\n    horizontal=True,\n    bar_width='index',\n    group_other=True,\n    column_sort_order=\"desc\",\n    column_sort_type=\"string\",\n    pro_bar_mode=\"combined\",\n    combination_mode=\"max\",\n    show_bar_labels=True,\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.bar(\n    x='keyword_column', \n    y='integer_column',\n    y2='float_column',\n    y2_style='dot',\n    horizontal=True,\n    bar_width='index',\n    group_other=True,\n    column_sort_order=\"desc\",\n    column_sort_type=\"string\",\n    pro_bar_mode=\"combined\",\n    combination_mode=\"max\",\n    show_bar_labels=True,\n)\n</code></pre> </p>"},{"location":"plotting/basic_charts/#chart-name","title":"Chart Name","text":"<p>Coming soon!</p>"},{"location":"plotting/basic_charts/#line","title":"Line","text":""},{"location":"plotting/basic_charts/#simple_1","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.line(df, x='datetime_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.line(x='datetime_column', y='integer_column')\n</code></pre> </p>"},{"location":"plotting/basic_charts/#customized_1","title":"Customized","text":"<p>You may need to use a larger dataset to see the changes here. For these examples, we used <code>dx.random_dataframe(5000)</code>.</p> dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.line(\n    df, \n    x='datetime_column', \n    y='integer_column',\n    line_type=\"cumulative\",\n    split_by=\"keyword_column\",\n    multi_axis=True,\n    smoothing=\"hourly\",\n    use_count=True,\n    bounding_type=\"relative\",\n    zero_baseline=True,\n    combination_mode=\"min\",\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.line(\n    x='datetime_column', \n    y='integer_column',\n    line_type=\"cumulative\",\n    split_by=\"keyword_column\",\n    multi_axis=True,\n    smoothing=\"hourly\",\n    use_count=True,\n    bounding_type=\"relative\",\n    zero_baseline=True,\n    combination_mode=\"min\",\n)\n</code></pre> </p>"},{"location":"plotting/basic_charts/#pie","title":"Pie","text":""},{"location":"plotting/basic_charts/#simple_2","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.pie(df, y='index')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.pie(y='index')\n</code></pre> </p>"},{"location":"plotting/basic_charts/#customized_2","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.pie(\n    df, \n    y='index',\n    split_slices_by='keyword_column',\n    show_total=False,\n    pie_label_type='annotation',\n    pie_label_contents='percent',\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.pie(\n    y='index',\n    split_slices_by='keyword_column',\n    show_total=False,\n    pie_label_type='annotation',\n    pie_label_contents='percent',\n)\n</code></pre> </p>"},{"location":"plotting/basic_charts/#scatter","title":"Scatter","text":""},{"location":"plotting/basic_charts/#simple_3","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.scatter(df, x='float_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p>Known Issue</p> <p><code>df.plot.scatter()</code> can be used unless <code>size</code> is specified. If you wish to use pandas syntax and provide a <code>size</code> argument, please use <code>df.plot(kind='scatter', ...)</code>.</p> <p><pre><code>df.plot(kind='scatter', x='float_column', y='integer_column')\n</code></pre> </p>"},{"location":"plotting/basic_charts/#customized_3","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.scatter(\n    df, \n    x='float_column', \n    y='integer_column',\n    size='index',\n    trend_line='polynomial',\n    marginal_graphics='histogram',\n    formula_display='r2'\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p>Known Issue</p> <p><code>df.plot.scatter()</code> can be used unless <code>size</code> is specified. If you wish to use pandas syntax and provide a <code>size</code> argument, please use <code>df.plot(kind='scatter', ...)</code>.</p> <p><pre><code>df.plot(\n    kind='scatter',\n    x='float_column', \n    y='integer_column',\n    size='index',\n    trend_line='polynomial',\n    marginal_graphics='histogram',\n    formula_display='r2'\n)\n</code></pre> </p>"},{"location":"plotting/basic_charts/#tilemap","title":"Tilemap","text":"<p>Since <code>dx.random_dataframe()</code> returns <code>integer_column</code> values (<code>-100</code> to <code>100</code>) and <code>float_column</code> values (<code>0.0</code> to <code>1.0</code>) as the only numeric columns by default, we can suggest enabling the <code>lat_float_column</code> and <code>lon_float_column</code> arguments for some quick testing: <pre><code>df = dx.random_dataframe(100, lat_float_column=True, lon_float_column=True)\n</code></pre></p> <p>More about how Noteable builds with Mapbox here. \ud83d\uddfa\ufe0f</p>"},{"location":"plotting/basic_charts/#simple_4","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.tilemap(df, lon='lon_float_column', lat='lat_float_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='tilemap', lon='lon_float_column', lat='lat_float_column')\n</code></pre> *Note you can't use <code>df.plot.tilemap()</code> directly</p> <p></p>"},{"location":"plotting/basic_charts/#customized_4","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.tilemap(\n    df,\n    lat='lat_float_column',\n    lon='lon_float_column',\n    icon_opacity=0.5,\n    icon_size='index',\n    icon_size_scale=\"log\",\n    stroke_color=\"magenta\",\n    stroke_width=5,\n    label_column='bytes_column',\n    tile_layer=\"light\",\n    hover_cols=['keyword_column', 'datetime_column'],\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='tilemap',\n    lat='lat_float_column',\n    lon='lon_float_column',\n    icon_opacity=0.5,\n    icon_size='index',\n    icon_size_scale=\"log\",\n    stroke_color=\"magenta\",\n    stroke_width=5,\n    label_column='bytes_column',\n    tile_layer=\"light\",\n    hover_cols=['keyword_column', 'datetime_column'],\n)\n</code></pre> *Note you can't use <code>df.plot.tilemap()</code> directly</p> <p></p>"},{"location":"plotting/basic_charts/#violin","title":"Violin","text":""},{"location":"plotting/basic_charts/#simple_5","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.violin(df, split_by='keyword_column', metric='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='violin', split_by='keyword_column', metric='integer_column')\n</code></pre> *Note you can't use <code>df.plot.violin()</code> directly</p> <p></p>"},{"location":"plotting/basic_charts/#customized_5","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.violin(\n    df, \n    split_by='keyword_column', \n    metric='integer_column',\n    bins=5,\n    show_interquartile_range=True,\n    column_sort_order='desc',\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='violin',\n    split_by='keyword_column', \n    metric='integer_column',\n    bins=5,\n    show_interquartile_range=True,\n    column_sort_order='desc',\n)\n</code></pre> *Note you can't use <code>df.plot.violin()</code> directly</p> <p></p>"},{"location":"plotting/basic_charts/#wordcloud","title":"Wordcloud","text":""},{"location":"plotting/basic_charts/#simple_6","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.wordcloud(df, word_column='keyword_column', size='float_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='wordcloud', word_column='keyword_column', size='float_column')\n</code></pre> *Note you can't use <code>df.plot.wordcloud()</code> directly</p> <p></p>"},{"location":"plotting/basic_charts/#customized_6","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.wordcloud(\n    df, \n    word_column='dtype_column',\n    size='float_column',\n    text_format='token',\n    word_rotation='45',\n    random_coloring=True,\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='wordcloud',\n    word_column='keyword_column',\n    word_column='dtype_column',\n    size='float_column',\n    text_format='token',\n    word_rotation='45',\n    random_coloring=True,\n)\n</code></pre> *Note you can't use <code>df.plot.wordcloud()</code> directly</p> <p></p>"},{"location":"plotting/comparison_charts/","title":"Comparison Charts","text":"<p>Here we'll talk about how to plot some comparison chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/comparison_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/comparison_charts/#bar","title":"Bar","text":""},{"location":"plotting/comparison_charts/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.bar(df, x='keyword_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.bar(x='keyword_column', y='integer_column')\n</code></pre> </p>"},{"location":"plotting/comparison_charts/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.bar(\n    df, \n    x='keyword_column', \n    y='integer_column',\n    y2='float_column',\n    y2_style='dot',\n    horizontal=True,\n    bar_width='index',\n    group_other=True,\n    column_sort_order=\"desc\",\n    column_sort_type=\"string\",\n    pro_bar_mode=\"combined\",\n    combination_mode=\"max\",\n    show_bar_labels=True,\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.bar(\n    x='keyword_column', \n    y='integer_column',\n    y2='float_column',\n    y2_style='dot',\n    horizontal=True,\n    bar_width='index',\n    group_other=True,\n    column_sort_order=\"desc\",\n    column_sort_type=\"string\",\n    pro_bar_mode=\"combined\",\n    combination_mode=\"max\",\n    show_bar_labels=True,\n)\n</code></pre> </p>"},{"location":"plotting/comparison_charts/#connected-scatterplot","title":"Connected Scatterplot","text":"<p>Coming soon!</p>"},{"location":"plotting/comparison_charts/#correlation-matrix","title":"Correlation Matrix","text":"<p>Coming soon!</p>"},{"location":"plotting/comparison_charts/#diverging-bar","title":"Diverging Bar","text":"<p>Coming soon!</p>"},{"location":"plotting/comparison_charts/#dot-plot","title":"Dot Plot","text":"<p>Coming soon!</p>"},{"location":"plotting/comparison_charts/#radar-plot","title":"Radar Plot","text":"<p>Coming soon!</p>"},{"location":"plotting/comparison_charts/#parallel-coordinates","title":"Parallel Coordinates","text":"<p>Coming soon!</p>"},{"location":"plotting/comparison_charts/#scatter","title":"Scatter","text":""},{"location":"plotting/comparison_charts/#simple_1","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.scatter(df, x='float_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p>Known Issue</p> <p><code>df.plot.scatter()</code> can be used unless <code>size</code> is specified. If you wish to use pandas syntax and provide a <code>size</code> argument, please use <code>df.plot(kind='scatter', ...)</code>.</p> <p><pre><code>df.plot(kind='scatter', x='float_column', y='integer_column')\n</code></pre> </p>"},{"location":"plotting/comparison_charts/#customized_1","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.scatter(\n    df, \n    x='float_column', \n    y='integer_column',\n    size='index',\n    trend_line='polynomial',\n    marginal_graphics='histogram',\n    formula_display='r2'\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p>Known Issue</p> <p><code>df.plot.scatter()</code> can be used unless <code>size</code> is specified. If you wish to use pandas syntax and provide a <code>size</code> argument, please use <code>df.plot(kind='scatter', ...)</code>.</p> <p><pre><code>df.plot(\n    kind='scatter',\n    x='float_column', \n    y='integer_column',\n    size='index',\n    trend_line='polynomial',\n    marginal_graphics='histogram',\n    formula_display='r2'\n)\n</code></pre> </p>"},{"location":"plotting/comparison_charts/#scatterplot-matrix","title":"Scatterplot Matrix","text":"<p>Coming soon!</p>"},{"location":"plotting/conditional_formatting/","title":"Conditional formatting","text":"<p>Coming soon!</p>"},{"location":"plotting/dashboards/","title":"Dashboards","text":"<p>Just like the plotting functions, generating dashboards with <code>dx</code> is very experimental and prone to change.</p>"},{"location":"plotting/dashboards/#making-a-dashboard","title":"Making a Dashboard","text":"<p>If you create charts using <code>dx</code> functions, you may want to combine them into a single view or dashboard. This can be done with <code>dashboard()</code>.</p> <p>Similar to the chart functions, <code>dashboard()</code> mainly requires a pandas DataFrame, as well as a list of views in a matrix-like orientation. (Each item in the list is treated as a row, and each row can be a list of views to specify column positioning.) </p>"},{"location":"plotting/dashboards/#simple","title":"Simple","text":"<p>Here's a quick example where we make a dashboard using two rows -- the top row will have scatter and bar charts, and the bottom will be our default grid view:</p> <p><pre><code>dx.dashboard(\n    df,\n    views=[\n        [\"scatter\", \"pie\"],\n        [\"grid\"],\n    ],\n)\n</code></pre> </p>"},{"location":"plotting/dashboards/#with-chart-views","title":"With Chart Views","text":"<p>Using chart functions, you can specify <code>return_view=True</code> and pass the resulting <code>DEXView</code> object into a dashboard.  <pre><code>custom_bar_chart = dx.bar(\n    df,\n    x='keyword_column',\n    y='integer_column',\n    column_sort_order='desc',\n    column_sort_type='string',\n    show_bar_labels=True,\n    return_view=True,\n)\n\nsimple_tilemap = dx.tilemap(\n    df,\n    lat='index',\n    lon='integer_column',\n    return_view=True,\n)\n\ndx.dashboard(\n    df,\n    views=[\n        [\"parallel_coordinates\", custom_bar_chart],\n        [simple_tilemap, 'pie', 'grid']\n    ]\n)\n</code></pre> </p>"},{"location":"plotting/dashboards/#customized","title":"Customized","text":"<p>If you want to provide some additional arguments, instead of passing a string to indicate the chart type, you can pass a dictionary with <code>{\"chart_mode\": CHART TYPE, **extra_kwargs}</code>. <pre><code>custom_chart = {\n    \"chart_mode\": \"hexbin\",\n    \"decoration\": {\n        \"title\": \"look at this sweet hexbin\"\n    },\n}\n\ndx.dashboard(\n    df, \n    views=[\n        [custom_chart, \"force_directed_network\"], \n        [\"ridgeline\"]\n    ]\n)\n</code></pre> </p>"},{"location":"plotting/faceting/","title":"Faceting","text":"<p>Coming soon!</p>"},{"location":"plotting/funnel_charts/","title":"Funnel Charts","text":"<p>Here we'll talk about how to plot some funnel chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/funnel_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/funnel_charts/#flow-diagram","title":"Flow Diagram","text":"<p>Coming soon!</p>"},{"location":"plotting/funnel_charts/#funnel","title":"Funnel","text":"<p>Coming soon!</p>"},{"location":"plotting/funnel_charts/#funnel-chart","title":"Funnel Chart","text":"<p>Coming soon!</p>"},{"location":"plotting/funnel_charts/#funnel-sunburst","title":"Funnel Sunburst","text":"<p>Coming soon!</p>"},{"location":"plotting/funnel_charts/#funnel-tree","title":"Funnel Tree","text":"<p>Coming soon!</p>"},{"location":"plotting/maps/","title":"Maps","text":"<p>Here we'll talk about how to plot some maps in DEX using <code>dx</code>.</p>"},{"location":"plotting/maps/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/maps/#choropleth","title":"Choropleth","text":"<p>Coming soon!</p>"},{"location":"plotting/maps/#tilemap","title":"Tilemap","text":"<p>Since <code>dx.random_dataframe()</code> returns <code>integer_column</code> values (<code>-100</code> to <code>100</code>) and <code>float_column</code> values (<code>0.0</code> to <code>1.0</code>) as the only numeric columns by default, we can suggest enabling the <code>lat_float_column</code> and <code>lon_float_column</code> arguments for some quick testing: <pre><code>df = dx.random_dataframe(100, lat_float_column=True, lon_float_column=True)\n</code></pre></p> <p>More about how Noteable builds with Mapbox here. \ud83d\uddfa\ufe0f</p>"},{"location":"plotting/maps/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.tilemap(df, lon='lon_float_column', lat='lat_float_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='tilemap', lon='lon_float_column', lat='lat_float_column')\n</code></pre> *Note you can't use <code>df.plot.tilemap()</code> directly</p> <p></p>"},{"location":"plotting/maps/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.tilemap(\n    df,\n    lat='lat_float_column',\n    lon='lon_float_column',\n    icon_opacity=0.5,\n    icon_size='index',\n    icon_size_scale=\"log\",\n    stroke_color=\"magenta\",\n    stroke_width=5,\n    label_column='bytes_column',\n    tile_layer=\"light\",\n    hover_cols=['keyword_column', 'datetime_column'],\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='tilemap',\n    lat='lat_float_column',\n    lon='lon_float_column',\n    icon_opacity=0.5,\n    icon_size='index',\n    icon_size_scale=\"log\",\n    stroke_color=\"magenta\",\n    stroke_width=5,\n    label_column='bytes_column',\n    tile_layer=\"light\",\n    hover_cols=['keyword_column', 'datetime_column'],\n)\n</code></pre> *Note you can't use <code>df.plot.tilemap()</code> directly</p> <p></p>"},{"location":"plotting/overview/","title":"Overview","text":"<p>If you've ever worked with DEX, you may come up with the perfect visualization or dashboard and want to carry it with you to other notebooks. This can be accomplished by using <code>dx</code>'s built-in convenience functions.</p>"},{"location":"plotting/overview/#using-pandas-dataframe-attrs","title":"Using pandas DataFrame <code>.attrs</code>","text":"<p>Set <code>.attrs</code> to customize your DEX display any time your pandas DataFrame is displayed. <pre><code>df.attrs = {\n    'noteable': {\n        'decoration': {\n            'title': \"my super cool DEX dataframe\"\n        }\n    }\n}\ndf\n</code></pre> </p>"},{"location":"plotting/overview/#plotting","title":"Plotting","text":"<p>This is still very experimental. Any of the charts checked below indicate basic rendering should work (and allow manual user interactions in DEX), but not all combinations of plot arguments have been tested. Feedback welcome!</p> <p>For official DEX chart documentation, visit https://docs.noteable.io/product-docs/visualize-data/dex-charts. </p>"},{"location":"plotting/overview/#supported-charts","title":"Supported Charts","text":""},{"location":"plotting/overview/#basic-charts","title":"Basic Charts","text":"<ul> <li> Bar</li> <li> Line</li> <li> Pie</li> <li> Scatterplot</li> <li> Violin</li> <li> Wordcloud</li> <li> DataPrism</li> </ul>"},{"location":"plotting/overview/#comparison-charts","title":"Comparison Charts","text":"<ul> <li> Parallel Coordinates</li> <li> Scatterplot</li> <li> Connected Scatterplot</li> <li> Scatterplot Matrix</li> <li> Correlation Matrix</li> <li> Bar</li> <li> Dot Plot</li> <li> Radar Plot</li> <li> Diverging Bar</li> </ul>"},{"location":"plotting/overview/#time-series-charts","title":"Time Series Charts","text":"<ul> <li> Line</li> <li> Cumulative</li> <li> Stacked Area</li> <li> Line Percent</li> <li> Stacked Percent</li> <li> Candlestick</li> </ul>"},{"location":"plotting/overview/#relationship-charts","title":"Relationship Charts","text":"<ul> <li> Force-directed Network</li> <li> Sankey</li> <li> Arc Diagram</li> <li> Adjacency Matrix</li> <li> Dendrogram</li> </ul>"},{"location":"plotting/overview/#part-to-whole-charts","title":"Part-to-whole Charts","text":"<ul> <li> Pie</li> <li> Donut</li> <li> Sunburst</li> <li> Treemap</li> <li> Partition</li> </ul>"},{"location":"plotting/overview/#funnel-charts","title":"Funnel Charts","text":"<ul> <li> Funnel</li> <li> Funnel Chart</li> <li> Funnel Tree</li> <li> Funnel Sunburst</li> <li> Flow Diagram</li> <li> Arc Flow</li> </ul>"},{"location":"plotting/overview/#summary-charts","title":"Summary Charts","text":"<ul> <li> Big Number</li> <li> Wordcloud</li> <li> Dimension Matrix</li> <li> Violin</li> <li> Box Plot</li> <li> Heat Map</li> <li> Histogram</li> <li> Ridgeline</li> <li> Horizon</li> <li> Hexbin</li> </ul>"},{"location":"plotting/overview/#maps","title":"Maps","text":"<ul> <li> Choropleth</li> <li> Tilemap</li> </ul>"},{"location":"plotting/overview/#additional-functionality","title":"Additional Functionality","text":"<ul> <li> Dashboards</li> <li> Conditional Formatting</li> <li> Faceting</li> </ul>"},{"location":"plotting/overview/#enabling-pandas-plotting-backend","title":"Enabling pandas plotting backend","text":"<p>To enable the <code>dx</code> plotting backend and use <code>DataFrame.plot._____()</code> or <code>DataFrame.plot(kind=_____)</code> syntax, you can run either of the following: <pre><code>dx.enable_plotting_backend()\n</code></pre> Or <pre><code>pd.options.plotting.backend = \"dx\"\n</code></pre> (They currently do the same thing, but <code>dx.enable_plotting_backend()</code> may handle more convenience functionality in the future.)</p> <p>Warning</p> <p>Not all chart options above can be called using the <code>DataFrame.plot.______()</code> pattern. Some examples:</p> <ul> <li><code>df.plot.violin(**kwargs)</code> should instead be <code>df.plot(kind='violin', **kwargs)</code></li> <li><code>df.plot.wordcloud(**kwargs)</code> should instead be <code>df.plot(kind='wordcloud', **kwargs)</code></li> </ul>"},{"location":"plotting/part_to_whole_charts/","title":"Part-to-whole Charts","text":"<p>Here we'll talk about how to plot some part-to-whole chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/part_to_whole_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/part_to_whole_charts/#donut","title":"Donut","text":"<p>Coming soon!</p>"},{"location":"plotting/part_to_whole_charts/#partition","title":"Partition","text":"<p>Coming soon!</p>"},{"location":"plotting/part_to_whole_charts/#pie","title":"Pie","text":""},{"location":"plotting/part_to_whole_charts/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.pie(df, y='index')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.pie(y='index')\n</code></pre> </p>"},{"location":"plotting/part_to_whole_charts/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.pie(\n    df, \n    y='index',\n    split_slices_by='keyword_column',\n    show_total=False,\n    pie_label_type='annotation',\n    pie_label_contents='percent',\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.pie(\n    y='index',\n    split_slices_by='keyword_column',\n    show_total=False,\n    pie_label_type='annotation',\n    pie_label_contents='percent',\n)\n</code></pre> </p>"},{"location":"plotting/part_to_whole_charts/#sunburst","title":"Sunburst","text":"<p>Coming soon!</p>"},{"location":"plotting/part_to_whole_charts/#treemap","title":"Treemap","text":"<p>Coming soon!</p>"},{"location":"plotting/relationship_charts/","title":"Relationship Charts","text":"<p>Here we'll talk about how to plot some relationship chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/relationship_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/relationship_charts/#arc-diagram","title":"Arc Diagram","text":"<p>Coming soon!</p>"},{"location":"plotting/relationship_charts/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Coming soon!</p>"},{"location":"plotting/relationship_charts/#dendrogram","title":"Dendrogram","text":"<p>Coming soon!</p>"},{"location":"plotting/relationship_charts/#force-directed-network","title":"Force-directed Network","text":"<p>Coming soon!</p>"},{"location":"plotting/relationship_charts/#sankey","title":"Sankey","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/","title":"Summary Charts","text":"<p>Here we'll talk about how to plot some summary chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/summary_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/summary_charts/#big-number","title":"Big Number","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#boxplot","title":"Boxplot","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#dimension-matrix","title":"Dimension Matrix","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#heatmap","title":"Heatmap","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#hexbin","title":"Hexbin","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#histogram","title":"Histogram","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#horizon","title":"Horizon","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#ridgeline","title":"Ridgeline","text":"<p>Coming soon!</p>"},{"location":"plotting/summary_charts/#violin","title":"Violin","text":""},{"location":"plotting/summary_charts/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.violin(df, split_by='keyword_column', metric='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(kind='violin', split_by='keyword_column', metric='integer_column')\n</code></pre> *Note you can't use <code>df.plot.violin()</code> directly</p> <p></p>"},{"location":"plotting/summary_charts/#customized","title":"Customized","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.violin(\n    df, \n    split_by='keyword_column', \n    metric='integer_column',\n    bins=5,\n    show_interquartile_range=True,\n    column_sort_order='desc',\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot(\n    kind='violin',\n    split_by='keyword_column', \n    metric='integer_column',\n    bins=5,\n    show_interquartile_range=True,\n    column_sort_order='desc',\n)\n</code></pre> *Note you can't use <code>df.plot.violin()</code> directly</p> <p></p>"},{"location":"plotting/time_series_charts/","title":"Time Series Charts","text":"<p>Here we'll talk about how to plot some time series chart types in DEX using <code>dx</code>.</p>"},{"location":"plotting/time_series_charts/#setup","title":"Setup","text":"<p>We will be using our own built-in DataFrame generation function for these visualizations. The values you see may be different if you run the same code in a cell, but the column structure should be very similar (if not identical). <pre><code>df = dx.random_dataframe(100)\n</code></pre></p> <p>The Customized examples with more options do not necessarily represent \"good\" data visualization; they are just a glimpse into what settings are available to compare against the Simple examples.</p>"},{"location":"plotting/time_series_charts/#candlestick","title":"Candlestick","text":"<p>Coming soon!</p>"},{"location":"plotting/time_series_charts/#cumulative","title":"Cumulative","text":"<p>Coming soon!</p>"},{"location":"plotting/time_series_charts/#line","title":"Line","text":""},{"location":"plotting/time_series_charts/#simple","title":"Simple","text":"dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.line(df, x='datetime_column', y='integer_column')\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.line(x='datetime_column', y='integer_column')\n</code></pre> </p>"},{"location":"plotting/time_series_charts/#customized","title":"Customized","text":"<p>You may need to use a larger dataset to see the changes here. For these examples, we used <code>dx.random_dataframe(5000)</code>.</p> dxpd.options.plotting.backend = 'dx' <p><pre><code>dx.line(\n    df, \n    x='datetime_column', \n    y='integer_column',\n    line_type=\"cumulative\",\n    split_by=\"keyword_column\",\n    multi_axis=True,\n    smoothing=\"hourly\",\n    use_count=True,\n    bounding_type=\"relative\",\n    zero_baseline=True,\n    combination_mode=\"min\",\n)\n</code></pre> </p> <p>Make sure you enable <code>dx</code> as a pandas plotting backend first.</p> <p><pre><code>df.plot.line(\n    x='datetime_column', \n    y='integer_column',\n    line_type=\"cumulative\",\n    split_by=\"keyword_column\",\n    multi_axis=True,\n    smoothing=\"hourly\",\n    use_count=True,\n    bounding_type=\"relative\",\n    zero_baseline=True,\n    combination_mode=\"min\",\n)\n</code></pre> </p>"},{"location":"plotting/time_series_charts/#line-percent","title":"Line Percent","text":"<p>Coming soon!</p>"},{"location":"plotting/time_series_charts/#stacked-area","title":"Stacked Area","text":"<p>Coming soon!</p>"},{"location":"plotting/time_series_charts/#stacked-percent","title":"Stacked Percent","text":"<p>Coming soon!</p>"},{"location":"reference/charts/basic_charts/","title":"Basic Charts","text":""},{"location":"reference/charts/basic_charts/#bar","title":"Bar","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.basic_charts.bar","title":"<code>src.dx.plotting.dex.basic_charts.bar(df, x, y, y2=None, y2_style='bar', horizontal=False, bar_width=None, group_other=False, column_sort_order='asc', column_sort_type='string', pro_bar_mode='combined', combination_mode='avg', show_bar_labels=False, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX bar plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>str</code> <p>The column(s) to use for the primary y-axis.</p> required <code>y2</code> <code>Optional[str]</code> <p>The column to use for the secondary y-axis.</p> <code>None</code> <code>y2_style</code> <code>DEXSecondMetricstyle</code> <p>The style to use for the secondary y-axis. (<code>\"bar\"</code> or <code>\"dot\"</code>)</p> <code>'bar'</code> <code>horizontal</code> <code>bool</code> <p>Whether to plot the bars horizontally.</p> <code>False</code> <code>bar_width</code> <code>Optional[str]</code> <p>The column to use for the bar width.</p> <code>None</code> <code>group_other</code> <code>bool</code> <p>Whether to group the remaining columns into an \"Other\" category.</p> <code>False</code> <code>column_sort_order</code> <code>DEXSortColumnsByOrder</code> <p>The order to sort the columns by (<code>\"asc\"</code> or <code>\"desc\"</code>)</p> <code>'asc'</code> <code>column_sort_type</code> <code>DEXSortColumnsByType</code> <p>The type of sorting to use. (<code>\"number\"</code>, <code>\"string\"</code>, or <code>\"date\"</code>)</p> <code>'string'</code> <code>pro_bar_mode</code> <code>DEXProBarModeType</code> <p>The bar mode to use (<code>\"clustered\"</code>, <code>\"combined\"</code>, or <code>\"stacked\"</code>).</p> <code>'combined'</code> <code>combination_mode</code> <code>DEXCombinationMode</code> <p>The combination mode to use (<code>\"avg\"</code>, <code>\"sum\"</code>, <code>\"min\"</code>, <code>\"median\"</code>, <code>\"max\"</code>, or <code>\"count\"</code>).</p> <code>'avg'</code> <code>show_bar_labels</code> <code>bool</code> <p>Whether to show the bar values as labels.</p> <code>False</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def bar(\n    df,\n    x: str,\n    y: str,\n    y2: Optional[str] = None,\n    y2_style: options.DEXSecondMetricstyle = \"bar\",\n    horizontal: bool = False,\n    bar_width: Optional[str] = None,\n    group_other: bool = False,\n    column_sort_order: options.DEXSortColumnsByOrder = \"asc\",\n    column_sort_type: options.DEXSortColumnsByType = \"string\",\n    pro_bar_mode: options.DEXProBarModeType = \"combined\",\n    combination_mode: options.DEXCombinationMode = \"avg\",\n    show_bar_labels: bool = False,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXBarChartView]:\n    \"\"\"\n    Generates a DEX bar plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: List[str]\n        The column(s) to use for the primary y-axis.\n    y2: Optional[str]\n        The column to use for the secondary y-axis.\n    y2_style: DEXSecondMetricstyle\n        The style to use for the secondary y-axis. (`\"bar\"` or `\"dot\"`)\n    horizontal: bool\n        Whether to plot the bars horizontally.\n    bar_width: Optional[str]\n        The column to use for the bar width.\n    group_other: bool\n        Whether to group the remaining columns into an \"Other\" category.\n    column_sort_order: DEXSortColumnsByOrder\n        The order to sort the columns by (`\"asc\"` or `\"desc\"`)\n    column_sort_type: DEXSortColumnsByType\n        The type of sorting to use. (`\"number\"`, `\"string\"`, or `\"date\"`)\n    pro_bar_mode: DEXProBarModeType\n        The bar mode to use (`\"clustered\"`, `\"combined\"`, or `\"stacked\"`).\n    combination_mode: DEXCombinationMode\n        The combination mode to use (`\"avg\"`, `\"sum\"`, `\"min\"`, `\"median\"`, `\"max\"`, or `\"count\"`).\n    show_bar_labels: bool\n        Whether to show the bar values as labels.\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns(x, df.columns)\n\n    if not isinstance(y, list):\n        y = [y]\n    raise_for_missing_columns(y, df.columns)\n    y1 = y[0]\n\n    chart_settings = {\n        \"dim1\": x,\n        \"metric1\": y1,\n        \"bar_projection\": \"horizontal\" if horizontal else \"vertical\",\n        \"sort_columns_by\": f\"{column_sort_order}-col-{column_sort_type}\",\n        \"group_other\": group_other,\n        \"combination_mode\": combination_mode,\n        \"bar_label\": \"show\" if show_bar_labels else \"none\",\n        \"selected_bar_metrics\": y,\n    }\n    if bar_width is not None:\n        chart_settings[\"metric3\"] = bar_width\n    if y2 is not None:\n        chart_settings[\"second_bar_metric\"] = y2\n        chart_settings[\"pro_bar_mode\"] = pro_bar_mode\n        chart_settings[\"second_metric_style\"] = y2_style\n\n    return handle_view(\n        df,\n        chart_mode=\"bar\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#line","title":"Line","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.basic_charts.line","title":"<code>src.dx.plotting.dex.basic_charts.line(df, x, y, line_type='line', split_by=None, multi_axis=False, smoothing=None, use_count=False, bounding_type='absolute', zero_baseline=False, combination_mode='avg', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX line plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>Union[List[str], str]</code> <p>The column(s) to use for the y-axis.</p> required <code>line_type</code> <code>DEXLineType</code> <p>The line type to use:     - <code>\"bumparea\"</code>     - <code>\"cumulative\"</code>     - <code>\"line\"</code> (default)     - <code>\"linepercent\"</code>     - <code>\"stackedarea\"</code>     - <code>\"stackedpercent\"</code></p> <code>'line'</code> <code>split_by</code> <code>Optional[str]</code> <p>The column to use for splitting the lines.</p> <code>None</code> <code>multi_axis</code> <code>bool</code> <p>Whether to use multiple y-axes.</p> <code>False</code> <code>smoothing</code> <code>Optional[DEXLineSmoothing]</code> <p>The line smoothing to use:     - <code>None</code> (default)     - <code>\"hourly\"</code>     - <code>\"daily\"</code>     - <code>\"weekly\"</code>     - <code>\"seven_day_moving_average\"</code>     - <code>\"monthly\"</code></p> <code>None</code> <code>use_count</code> <code>bool</code> <p>Whether to use the DEX_COUNT column for the y-axis.</p> <code>False</code> <code>bounding_type</code> <code>DEXBoundingType</code> <p>The bounding type to use:     - <code>\"absolute\"</code> (default)     - <code>\"relative\"</code></p> <code>'absolute'</code> <code>zero_baseline</code> <code>bool</code> <p>Whether to use a zero base line.</p> <code>False</code> <code>combination_mode</code> <code>DEXCombinationMode</code> <p>The combination mode to use (<code>\"avg\"</code>, <code>\"sum\"</code>, <code>\"min\"</code>, <code>\"median\"</code>, <code>\"max\"</code>, or <code>\"count\"</code>).</p> <code>'avg'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def line(\n    df,\n    x: str,\n    y: Union[List[str], str],\n    line_type: options.DEXLineType = \"line\",\n    split_by: Optional[str] = None,\n    multi_axis: bool = False,\n    smoothing: Optional[options.DEXLineSmoothing] = None,\n    use_count: bool = False,\n    bounding_type: options.DEXBoundingType = \"absolute\",\n    zero_baseline: bool = False,\n    combination_mode: options.DEXCombinationMode = \"avg\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXLineChartView]:\n    \"\"\"\n    Generates a DEX line plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: Union[List[str], str]\n        The column(s) to use for the y-axis.\n    line_type: DEXLineType\n        The line type to use:\n            - `\"bumparea\"`\n            - `\"cumulative\"`\n            - `\"line\"` (default)\n            - `\"linepercent\"`\n            - `\"stackedarea\"`\n            - `\"stackedpercent\"`\n    split_by: Optional[str]\n        The column to use for splitting the lines.\n    multi_axis: bool\n        Whether to use multiple y-axes.\n    smoothing: Optional[DEXLineSmoothing]\n        The line smoothing to use:\n            - `None` (default)\n            - `\"hourly\"`\n            - `\"daily\"`\n            - `\"weekly\"`\n            - `\"seven_day_moving_average\"`\n            - `\"monthly\"`\n    use_count: bool\n        Whether to use the DEX_COUNT column for the y-axis.\n    bounding_type: DEXBoundingType\n        The bounding type to use:\n            - `\"absolute\"` (default)\n            - `\"relative\"`\n    zero_baseline: bool\n        Whether to use a zero base line.\n    combination_mode: DEXCombinationMode\n        The combination mode to use (`\"avg\"`, `\"sum\"`, `\"min\"`, `\"median\"`, `\"max\"`, or `\"count\"`).\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns(x, df.columns)\n\n    if isinstance(y, str):\n        y = [y]\n    raise_for_missing_columns(y, df.columns)\n    if use_count:\n        y.append(\"DEX_COUNT\")\n\n    if split_by is not None:\n        if str(split_by) not in df.columns:\n            raise ValueError(f\"Column '{split_by}' not found in DataFrame.\")\n\n    chart_settings = {\n        \"bounding_type\": bounding_type,\n        \"combination_mode\": combination_mode,\n        \"line_smoothing\": smoothing or \"none\",\n        \"line_type\": line_type,\n        \"multi_axis_line\": multi_axis,\n        \"selected_metrics\": y,\n        \"split_lines_by\": split_by,\n        \"timeseries_sort\": x,\n        \"zero_baseline\": zero_baseline,\n    }\n    logger.debug(f\"{chart_settings=}\")\n    return handle_view(\n        df,\n        chart_mode=\"line\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#pie","title":"Pie","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.basic_charts.pie","title":"<code>src.dx.plotting.dex.basic_charts.pie(df, y, split_slices_by=None, show_total=True, pie_label_type='rim', pie_label_contents='name', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX pie plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>y</code> <code>str</code> <p>The column to use for the slice size.</p> required <code>split_slices_by</code> <code>Optional[str]</code> <p>The column to use for splitting the slices. If not provided, slices will be split and sized by <code>y</code>.</p> <code>None</code> <code>show_total</code> <code>bool</code> <p>Whether to show the total.</p> <code>True</code> <code>pie_label_type</code> <code>DEXPieLabelType</code> <p>The pie label type to use:     - <code>\"rim\"</code> (default)     - <code>\"annotation\"</code>     - <code>\"center\"</code>     - <code>\"stem\"</code>     - <code>\"none\"</code></p> <code>'rim'</code> <code>pie_label_contents</code> <code>DEXPieLabelContents</code> <p>The pie label contents to use:     - <code>\"name\"</code> (default)     - <code>\"value\"</code>     - <code>\"percent\"</code>     - <code>\"name_value\"</code>     - <code>\"name_percent\"</code>     - <code>\"value_percent\"</code></p> <code>'name'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def pie(\n    df,\n    y: str,\n    split_slices_by: Optional[str] = None,\n    show_total: bool = True,\n    pie_label_type: options.DEXPieLabelType = \"rim\",\n    pie_label_contents: options.DEXPieLabelContents = \"name\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXPieChartView]:\n    \"\"\"\n    Generates a DEX pie plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    y: str\n        The column to use for the slice size.\n    split_slices_by: Optional[str]\n        The column to use for splitting the slices. If not provided, slices will be split and sized by `y`.\n    show_total: bool\n        Whether to show the total.\n    pie_label_type: DEXPieLabelType\n        The pie label type to use:\n            - `\"rim\"` (default)\n            - `\"annotation\"`\n            - `\"center\"`\n            - `\"stem\"`\n            - `\"none\"`\n    pie_label_contents: DEXPieLabelContents\n        The pie label contents to use:\n            - `\"name\"` (default)\n            - `\"value\"`\n            - `\"percent\"`\n            - `\"name_value\"`\n            - `\"name_percent\"`\n            - `\"value_percent\"`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    if split_slices_by is None:\n        split_slices_by = y\n    raise_for_missing_columns([y, split_slices_by], df.columns)\n\n    chart_settings = {\n        \"dim1\": split_slices_by,\n        \"metric1\": y,\n        \"show_total\": show_total,\n        \"pie_label_type\": pie_label_type,\n        \"pie_label_contents\": pie_label_contents,\n    }\n    return handle_view(\n        df,\n        chart_mode=\"pie\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#scatter","title":"Scatter","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.basic_charts.scatter","title":"<code>src.dx.plotting.dex.basic_charts.scatter(df, x, y, size=None, trend_line=None, marginal_graphics=None, formula_display=None, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX scatterplot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>str</code> <p>The column to use for the y-axis.</p> required <code>size</code> <code>Optional[str]</code> <p>The column to use for sizing scatterplot points.</p> <code>None</code> <code>trend_line</code> <code>Optional[DEXTrendlineType]</code> <p>The type of trendline to use. One of <code>\"linear\"</code>, <code>\"exponential\"</code>, <code>\"polynomial\"</code>, <code>\"power\"</code>, or <code>\"logarithmic\"</code>.</p> <code>None</code> <code>marginal_graphics</code> <code>Optional[DEXSummaryType]</code> <p>The marginal graphics to use:     - <code>boxplot</code>     - <code>heatmap</code>     - <code>histogram</code>     - <code>horizon</code>     - <code>joy</code>     - <code>ridgeline</code>     - <code>violin</code></p> <code>None</code> <code>formula_display</code> <code>Optional[DEXFormulaDisplay]</code> <p>The formula display to use:     - <code>r2</code>     - <code>formula</code></p> <code>None</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def scatter(\n    df: pd.DataFrame,\n    x: str,\n    y: str,\n    size: Optional[str] = None,\n    trend_line: Optional[options.DEXTrendlineType] = None,\n    marginal_graphics: Optional[options.DEXSummaryType] = None,\n    formula_display: Optional[options.DEXFormulaDisplay] = None,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXScatterChartView]:\n    \"\"\"\n    Generates a DEX scatterplot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: str\n        The column to use for the y-axis.\n    size: Optional[str]\n        The column to use for sizing scatterplot points.\n    trend_line: Optional[DEXTrendlineType]\n        The type of trendline to use. One of `\"linear\"`, `\"exponential\"`, `\"polynomial\"`, `\"power\"`, or `\"logarithmic\"`.\n    marginal_graphics: Optional[DEXSummaryType]\n        The marginal graphics to use:\n            - `boxplot`\n            - `heatmap`\n            - `histogram`\n            - `horizon`\n            - `joy`\n            - `ridgeline`\n            - `violin`\n    formula_display: Optional[DEXFormulaDisplay]\n        The formula display to use:\n            - `r2`\n            - `formula`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([x, y], df.columns)\n\n    chart_settings = {\n        \"metric1\": x,\n        \"metric2\": y,\n    }\n    # if these are present but set to `None`, DEX gets angry\n    if trend_line is not None:\n        chart_settings[\"trendLine\"] = trend_line\n    if size is not None:\n        chart_settings[\"scatterplotSize\"] = size\n    if marginal_graphics is not None:\n        chart_settings[\"marginalGraphics\"] = marginal_graphics\n    if formula_display is not None:\n        chart_settings[\"formulaDisplay\"] = formula_display\n\n    return handle_view(\n        df,\n        chart_mode=\"scatter\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#tilemap","title":"Tilemap","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.map_charts.tilemap","title":"<code>src.dx.plotting.dex.map_charts.tilemap(df, lat, lon, icon_opacity=1.0, icon_size=2, icon_size_scale='linear', stroke_color='#000000', stroke_width=2, label_column=None, tile_layer='streets', hover_cols=None, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX tilemap from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>lat</code> <code>str</code> <p>The column to use for the latitude values.</p> required <code>lon</code> <code>str</code> <p>The column to use for the longitude values.</p> required <code>icon_opacity</code> <code>float</code> <p>The opacity to use for the icon (<code>0.0</code> to <code>1.0</code>)</p> <code>1.0</code> <code>icon_size</code> <code>int</code> <p>Either: - int: a fixed size to use for the icon (<code>0</code> to <code>10</code>) - str: a column name to use for functional sizing</p> <code>2</code> <code>icon_size_scale</code> <code>DEXScale</code> <p>The scale to use for functional sizing (<code>\"linear\"</code> or <code>\"log\"</code>)</p> <code>'linear'</code> <code>stroke_color</code> <code>Color</code> <p>The color to use for the icon stroke.</p> <code>'#000000'</code> <code>stroke_width</code> <code>int</code> <p>The width to use for the icon stroke.</p> <code>2</code> <code>tile_layer</code> <code>str</code> <p>The type of tile layer to use. One of <code>\"streets\"</code>, <code>\"outdoors\"</code>, <code>\"light\"</code>, <code>\"dark\"</code>, or <code>\"satellite\"</code></p> <code>'streets'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/map_charts.py</code> <pre><code>def tilemap(\n    df,\n    lat: str,\n    lon: str,\n    icon_opacity: float = 1.0,\n    icon_size: int = 2,\n    icon_size_scale: options.DEXScale = \"linear\",\n    stroke_color: Color = \"#000000\",\n    stroke_width: int = 2,\n    label_column: Optional[str] = None,\n    tile_layer: str = \"streets\",\n    hover_cols: Optional[List[str]] = None,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXTilemapChartView]:\n    \"\"\"\n    Generates a DEX tilemap from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    lat: str\n        The column to use for the latitude values.\n    lon: str\n        The column to use for the longitude values.\n    icon_opacity: float\n        The opacity to use for the icon (`0.0` to `1.0`)\n    icon_size: Union[int, str]\n        Either:\n        - int: a fixed size to use for the icon (`0` to `10`)\n        - str: a column name to use for functional sizing\n    icon_size_scale: DEXScale\n        The scale to use for functional sizing (`\"linear\"` or `\"log\"`)\n    stroke_color: Color\n        The color to use for the icon stroke.\n    stroke_width: int\n        The width to use for the icon stroke.\n    tile_layer: str\n        The type of tile layer to use. One of `\"streets\"`, `\"outdoors\"`, `\"light\"`, `\"dark\"`, or `\"satellite\"`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([lat, lon], df.columns)\n\n    if isinstance(hover_cols, str):\n        hover_cols = [hover_cols]\n    if hover_cols is None:\n        hover_cols = df.columns\n    else:\n        raise_for_missing_columns(hover_cols, df.columns)\n\n    if label_column is not None:\n        raise_for_missing_columns(label_column, df.columns)\n\n    if isinstance(icon_size, str):\n        # referencing a column, treat as functional sizing\n\n        if icon_size not in df.columns:\n            # \"index\" was chosen but isn't in columns, which passes raise_for_missing_columns()\n            series = df.index\n        else:\n            series = df[icon_size]\n\n        series_min = series.min()\n        if str(icon_size_scale).lower() == \"log\":\n            series_min = 1\n\n        point_size_opts = {\n            \"mode\": \"functional\",\n            \"size\": 2,\n            \"met\": icon_size,\n            \"scale\": icon_size_scale,\n            \"min\": series_min,\n            \"max\": series.max(),\n            \"sizeMin\": 1,\n            \"sizeMax\": 10,\n        }\n    elif isinstance(icon_size, int):\n        # fixed sizing, shouldn't matter what we put in here\n        point_size_opts = {\n            \"mode\": \"fixed\",\n            \"size\": icon_size,\n            \"met\": str(lon),\n            \"scale\": icon_size_scale,\n            \"min\": df[str(lon)].min(),\n            \"max\": df[str(lon)].max(),\n            \"sizeMin\": 1,\n            \"sizeMax\": 10,\n        }\n    else:\n        raise ValueError(f\"`{type(icon_size)}` is not a valid type for `icon_size`.\")\n\n    # determine which columns are numeric and which ones are strings/mixed/etc\n    dimension_cols = [col for col in hover_cols if df[col].dtype == \"object\"]\n    metric_cols = [col for col in hover_cols if col not in dimension_cols]\n\n    layer_settings = {\n        \"lat_dim\": lat,\n        \"long_dim\": lon,\n        \"transparency\": icon_opacity,\n        \"size\": icon_size,\n        \"type\": \"point\",\n        \"stroke\": stroke_color,\n        \"stroke_width\": stroke_width,\n        \"point_size_opts\": point_size_opts,\n        \"hover_opts\": {\n            \"dims\": dimension_cols,\n            \"mets\": metric_cols,\n        },\n        \"tile_layer\": tile_layer,\n    }\n    if label_column is not None:\n        layer_settings[\"show_labels\"] = label_column\n\n    chart_settings = {\n        \"map_mode\": \"tile\",\n        \"layer_settings\": [layer_settings],\n    }\n    return handle_view(\n        df,\n        chart_mode=\"tilemap\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#violin","title":"Violin","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.summary_charts.violin","title":"<code>src.dx.plotting.dex.summary_charts.violin(df, split_by, metric, bins=30, show_interquartile_range=False, column_sort_order='asc', column_sort_type='string', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX violin plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>split_by</code> <code>str</code> <p>The column to use for splitting the data.</p> required <code>metric</code> <code>str</code> <p>The column to use to show distribution and density.</p> required <code>bins</code> <code>int</code> <p>The number of bins to use for the violin plot.</p> <code>30</code> <code>show_interquartile_range</code> <code>bool</code> <p>Whether to show the interquartile range.</p> <code>False</code> <code>column_sort_order</code> <code>DEXSortColumnsByOrder</code> <p>The order to sort the columns by. (<code>\"asc\"</code> or <code>\"desc\"</code>)</p> <code>'asc'</code> <code>column_sort_type</code> <code>DEXSortColumnsByType</code> <p>The type of sorting to use. (<code>\"number\"</code>, <code>\"string\"</code>, or <code>\"date\"</code>)</p> <code>'string'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/summary_charts.py</code> <pre><code>def violin(\n    df: pd.DataFrame,\n    split_by: str,\n    metric: str,\n    bins: int = 30,\n    show_interquartile_range: bool = False,\n    column_sort_order: options.DEXSortColumnsByOrder = \"asc\",\n    column_sort_type: options.DEXSortColumnsByType = \"string\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXViolinChartView]:\n    \"\"\"\n    Generates a DEX violin plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    split_by: str\n        The column to use for splitting the data.\n    metric: str\n        The column to use to show distribution and density.\n    bins: int\n        The number of bins to use for the violin plot.\n    show_interquartile_range: bool\n        Whether to show the interquartile range.\n    column_sort_order: DEXSortColumnsByOrder\n        The order to sort the columns by. (`\"asc\"` or `\"desc\"`)\n    column_sort_type: DEXSortColumnsByType\n        The type of sorting to use. (`\"number\"`, `\"string\"`, or `\"date\"`)\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    if str(column_sort_order).lower() == \"asc\":\n        sort_order = \"desc\"\n    elif str(column_sort_order).lower() == \"desc\":\n        sort_order = \"asc\"\n    chart_params = dict(\n        summary_bins=bins,\n        sort_columns_by=f\"{sort_order}-col-{column_sort_type}\",\n        violin_iqr=show_interquartile_range,\n    )\n    return summary(\n        df,\n        split_by=split_by,\n        metric=metric,\n        summary_type=\"violin\",\n        chart_params=chart_params,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#wordcloud","title":"Wordcloud","text":""},{"location":"reference/charts/basic_charts/#src.dx.plotting.dex.basic_charts.wordcloud","title":"<code>src.dx.plotting.dex.basic_charts.wordcloud(df, word_column, size, text_format='sentence', word_rotation=None, random_coloring=False, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX wordcloud from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>word_column</code> <code>str</code> <p>The column to use for the words in the cloud.</p> required <code>size</code> <code>str</code> <p>The column to use for the size of the words in the cloud.</p> required <code>text_format</code> <code>DEXTextDataFormat</code> <p>The format of the text data. Either <code>\"sentence\"</code> or <code>\"token\"</code>.</p> <code>'sentence'</code> <code>word_rotation</code> <code>Optional[DEXWordRotate]</code> <p>The rotation to use for the words in the cloud (<code>45</code>, <code>90</code>, <code>\"jitter\"</code>, or <code>None</code>).</p> <code>None</code> <code>random_coloring</code> <code>bool</code> <p>Whether to use random coloring for the words in the cloud.</p> <code>False</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def wordcloud(\n    df: pd.DataFrame,\n    word_column: str,\n    size: str,\n    text_format: options.DEXTextDataFormat = \"sentence\",\n    word_rotation: Optional[options.DEXWordRotate] = None,\n    random_coloring: bool = False,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXWordcloudChartView]:\n    \"\"\"\n    Generates a DEX wordcloud from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    word_column: str\n        The column to use for the words in the cloud.\n    size: str\n        The column to use for the size of the words in the cloud.\n    text_format: DEXTextDataFormat\n        The format of the text data. Either `\"sentence\"` or `\"token\"`.\n    word_rotation: Optional[DEXWordRotate]\n        The rotation to use for the words in the cloud (`45`, `90`, `\"jitter\"`, or `None`).\n    random_coloring: bool\n        Whether to use random coloring for the words in the cloud.\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([word_column, size], df.columns)\n\n    chart_settings = {\n        \"text_data_format\": text_format,\n        \"token_metric\": size,\n        \"word_data\": word_column,\n        \"word_color\": \"random\" if random_coloring else \"none\",\n        \"word_rotate\": word_rotation if word_rotation else \"none\",\n    }\n    return handle_view(\n        df,\n        chart_mode=\"wordcloud\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/basic_charts/#chart-name","title":"Chart Name","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/","title":"Comparison Charts","text":""},{"location":"reference/charts/comparison_charts/#parallel-coordinates","title":"Parallel Coordinates","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/#scatter","title":"Scatter","text":""},{"location":"reference/charts/comparison_charts/#src.dx.plotting.dex.basic_charts.scatter","title":"<code>src.dx.plotting.dex.basic_charts.scatter(df, x, y, size=None, trend_line=None, marginal_graphics=None, formula_display=None, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX scatterplot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>str</code> <p>The column to use for the y-axis.</p> required <code>size</code> <code>Optional[str]</code> <p>The column to use for sizing scatterplot points.</p> <code>None</code> <code>trend_line</code> <code>Optional[DEXTrendlineType]</code> <p>The type of trendline to use. One of <code>\"linear\"</code>, <code>\"exponential\"</code>, <code>\"polynomial\"</code>, <code>\"power\"</code>, or <code>\"logarithmic\"</code>.</p> <code>None</code> <code>marginal_graphics</code> <code>Optional[DEXSummaryType]</code> <p>The marginal graphics to use:     - <code>boxplot</code>     - <code>heatmap</code>     - <code>histogram</code>     - <code>horizon</code>     - <code>joy</code>     - <code>ridgeline</code>     - <code>violin</code></p> <code>None</code> <code>formula_display</code> <code>Optional[DEXFormulaDisplay]</code> <p>The formula display to use:     - <code>r2</code>     - <code>formula</code></p> <code>None</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def scatter(\n    df: pd.DataFrame,\n    x: str,\n    y: str,\n    size: Optional[str] = None,\n    trend_line: Optional[options.DEXTrendlineType] = None,\n    marginal_graphics: Optional[options.DEXSummaryType] = None,\n    formula_display: Optional[options.DEXFormulaDisplay] = None,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXScatterChartView]:\n    \"\"\"\n    Generates a DEX scatterplot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: str\n        The column to use for the y-axis.\n    size: Optional[str]\n        The column to use for sizing scatterplot points.\n    trend_line: Optional[DEXTrendlineType]\n        The type of trendline to use. One of `\"linear\"`, `\"exponential\"`, `\"polynomial\"`, `\"power\"`, or `\"logarithmic\"`.\n    marginal_graphics: Optional[DEXSummaryType]\n        The marginal graphics to use:\n            - `boxplot`\n            - `heatmap`\n            - `histogram`\n            - `horizon`\n            - `joy`\n            - `ridgeline`\n            - `violin`\n    formula_display: Optional[DEXFormulaDisplay]\n        The formula display to use:\n            - `r2`\n            - `formula`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([x, y], df.columns)\n\n    chart_settings = {\n        \"metric1\": x,\n        \"metric2\": y,\n    }\n    # if these are present but set to `None`, DEX gets angry\n    if trend_line is not None:\n        chart_settings[\"trendLine\"] = trend_line\n    if size is not None:\n        chart_settings[\"scatterplotSize\"] = size\n    if marginal_graphics is not None:\n        chart_settings[\"marginalGraphics\"] = marginal_graphics\n    if formula_display is not None:\n        chart_settings[\"formulaDisplay\"] = formula_display\n\n    return handle_view(\n        df,\n        chart_mode=\"scatter\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/comparison_charts/#connected-scatterplot","title":"Connected Scatterplot","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/#scatterplot-matrix","title":"Scatterplot Matrix","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/#correlation-matrix","title":"Correlation Matrix","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/#bar","title":"Bar","text":""},{"location":"reference/charts/comparison_charts/#src.dx.plotting.dex.basic_charts.bar","title":"<code>src.dx.plotting.dex.basic_charts.bar(df, x, y, y2=None, y2_style='bar', horizontal=False, bar_width=None, group_other=False, column_sort_order='asc', column_sort_type='string', pro_bar_mode='combined', combination_mode='avg', show_bar_labels=False, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX bar plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>str</code> <p>The column(s) to use for the primary y-axis.</p> required <code>y2</code> <code>Optional[str]</code> <p>The column to use for the secondary y-axis.</p> <code>None</code> <code>y2_style</code> <code>DEXSecondMetricstyle</code> <p>The style to use for the secondary y-axis. (<code>\"bar\"</code> or <code>\"dot\"</code>)</p> <code>'bar'</code> <code>horizontal</code> <code>bool</code> <p>Whether to plot the bars horizontally.</p> <code>False</code> <code>bar_width</code> <code>Optional[str]</code> <p>The column to use for the bar width.</p> <code>None</code> <code>group_other</code> <code>bool</code> <p>Whether to group the remaining columns into an \"Other\" category.</p> <code>False</code> <code>column_sort_order</code> <code>DEXSortColumnsByOrder</code> <p>The order to sort the columns by (<code>\"asc\"</code> or <code>\"desc\"</code>)</p> <code>'asc'</code> <code>column_sort_type</code> <code>DEXSortColumnsByType</code> <p>The type of sorting to use. (<code>\"number\"</code>, <code>\"string\"</code>, or <code>\"date\"</code>)</p> <code>'string'</code> <code>pro_bar_mode</code> <code>DEXProBarModeType</code> <p>The bar mode to use (<code>\"clustered\"</code>, <code>\"combined\"</code>, or <code>\"stacked\"</code>).</p> <code>'combined'</code> <code>combination_mode</code> <code>DEXCombinationMode</code> <p>The combination mode to use (<code>\"avg\"</code>, <code>\"sum\"</code>, <code>\"min\"</code>, <code>\"median\"</code>, <code>\"max\"</code>, or <code>\"count\"</code>).</p> <code>'avg'</code> <code>show_bar_labels</code> <code>bool</code> <p>Whether to show the bar values as labels.</p> <code>False</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def bar(\n    df,\n    x: str,\n    y: str,\n    y2: Optional[str] = None,\n    y2_style: options.DEXSecondMetricstyle = \"bar\",\n    horizontal: bool = False,\n    bar_width: Optional[str] = None,\n    group_other: bool = False,\n    column_sort_order: options.DEXSortColumnsByOrder = \"asc\",\n    column_sort_type: options.DEXSortColumnsByType = \"string\",\n    pro_bar_mode: options.DEXProBarModeType = \"combined\",\n    combination_mode: options.DEXCombinationMode = \"avg\",\n    show_bar_labels: bool = False,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXBarChartView]:\n    \"\"\"\n    Generates a DEX bar plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: List[str]\n        The column(s) to use for the primary y-axis.\n    y2: Optional[str]\n        The column to use for the secondary y-axis.\n    y2_style: DEXSecondMetricstyle\n        The style to use for the secondary y-axis. (`\"bar\"` or `\"dot\"`)\n    horizontal: bool\n        Whether to plot the bars horizontally.\n    bar_width: Optional[str]\n        The column to use for the bar width.\n    group_other: bool\n        Whether to group the remaining columns into an \"Other\" category.\n    column_sort_order: DEXSortColumnsByOrder\n        The order to sort the columns by (`\"asc\"` or `\"desc\"`)\n    column_sort_type: DEXSortColumnsByType\n        The type of sorting to use. (`\"number\"`, `\"string\"`, or `\"date\"`)\n    pro_bar_mode: DEXProBarModeType\n        The bar mode to use (`\"clustered\"`, `\"combined\"`, or `\"stacked\"`).\n    combination_mode: DEXCombinationMode\n        The combination mode to use (`\"avg\"`, `\"sum\"`, `\"min\"`, `\"median\"`, `\"max\"`, or `\"count\"`).\n    show_bar_labels: bool\n        Whether to show the bar values as labels.\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns(x, df.columns)\n\n    if not isinstance(y, list):\n        y = [y]\n    raise_for_missing_columns(y, df.columns)\n    y1 = y[0]\n\n    chart_settings = {\n        \"dim1\": x,\n        \"metric1\": y1,\n        \"bar_projection\": \"horizontal\" if horizontal else \"vertical\",\n        \"sort_columns_by\": f\"{column_sort_order}-col-{column_sort_type}\",\n        \"group_other\": group_other,\n        \"combination_mode\": combination_mode,\n        \"bar_label\": \"show\" if show_bar_labels else \"none\",\n        \"selected_bar_metrics\": y,\n    }\n    if bar_width is not None:\n        chart_settings[\"metric3\"] = bar_width\n    if y2 is not None:\n        chart_settings[\"second_bar_metric\"] = y2\n        chart_settings[\"pro_bar_mode\"] = pro_bar_mode\n        chart_settings[\"second_metric_style\"] = y2_style\n\n    return handle_view(\n        df,\n        chart_mode=\"bar\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/comparison_charts/#dot-plot","title":"Dot Plot","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/#radar-plot","title":"Radar Plot","text":"<p>Coming soon!</p>"},{"location":"reference/charts/comparison_charts/#diverging-bar","title":"Diverging Bar","text":"<p>Coming soon!</p>"},{"location":"reference/charts/dashboards/","title":"Dashboards","text":""},{"location":"reference/charts/dashboards/#making-a-dashboard","title":"Making a Dashboard","text":""},{"location":"reference/charts/dashboards/#src.dx.plotting.dashboards.dashboard","title":"<code>src.dx.plotting.dashboards.dashboard(df, views, **kwargs)</code>","text":"<p>Creates and renders a DEX dashboard from a list of views.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to be rendered.</p> required <code>views</code> <code>List[Union[str, dict, list, DEXView]]</code> <p>A list of views to be created and rendered in the dashboard. By default, each item in the list will be treated as a row item. Each item in the list can be another nested list of views to determine column positioning within the dashboard view.</p> required Source code in <code>src/dx/plotting/dashboards.py</code> <pre><code>def dashboard(\n    df: pd.DataFrame,\n    views: List[Union[str, dict, list, DEXView]],\n    **kwargs,\n) -&gt; Optional[DEXMetadata]:\n    \"\"\"\n    Creates and renders a DEX dashboard from a list of views.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The dataframe to be rendered.\n    views: List[Union[str, dict, list, DEXView]]\n        A list of views to be created and rendered in the dashboard.\n        By default, each item in the list will be treated as a row item.\n        Each item in the list can be another nested list of views to\n        determine column positioning within the dashboard view.\n    \"\"\"\n    dex_metadata = DEXMetadata()\n    multiview_order = []\n\n    # generate and add views, assuming a matrix-like structure\n    for row_num, views_row in enumerate(views):\n        if not isinstance(views_row, list):\n            views_row = [views_row]\n        for col_num, view in enumerate(views_row):\n            if isinstance(view, str):\n                # get the direct-to-chart option since we can't pass kwargs\n                view = dex.get_chart_view(df, f\"sample_{view.lower()}\")\n            elif isinstance(view, dict):\n                # view dict\n                dex_view = DEXView.parse_obj(view)\n            elif isinstance(view, DEXView):\n                dex_view = view\n            else:\n                raise ValueError(f\"Invalid view type: {type(view)}\")\n\n            # make the views available for reference\n            dex_dashboard_view = dex_view.copy(\n                update={\"is_default\": False, \"chartMode\": dex_view.chart_mode}\n            )\n            # TODO: make DEXMetadata.add_view() support adding DEXView\n            # instead of just dictionaries\n            dex_dashboard_view_dict = dex_dashboard_view.dict(\n                by_alias=True,\n                exclude_none=True,\n            )\n            logger.debug(f\"{dex_dashboard_view_dict=}\")\n            dex_metadata.views.append(dex_dashboard_view_dict)\n            # define the view positioning\n            multiview = {\n                \"column\": col_num,\n                \"row\": row_num,\n                \"id\": str(dex_dashboard_view.id),\n            }\n            multiview_order.append(multiview)\n\n    dashboard_view_metadata = {\n        \"views\": multiview_order,\n        \"isDefault\": True,\n        \"decoration\": {\n            \"title\": \"\ud83e\udd14 dx dashboard\",\n        },\n    }\n    dashboard_view_metadata.update(kwargs)\n\n    dex_dashboard_metadata = DEXView.parse_obj(dashboard_view_metadata)\n\n    with settings_context(generate_dex_metadata=True):\n        handle_format(\n            df,\n            extra_metadata={\n                \"dashboard\": {\n                    \"multiViews\": [\n                        dex_dashboard_metadata.dict(by_alias=True),\n                    ],\n                },\n                \"views\": dex_metadata.views,\n            },\n        )\n</code></pre>"},{"location":"reference/charts/funnel_charts/","title":"Funnel Charts","text":""},{"location":"reference/charts/funnel_charts/#funnel","title":"Funnel","text":"<p>Coming soon!</p>"},{"location":"reference/charts/funnel_charts/#funnel-chart","title":"Funnel Chart","text":"<p>Coming soon!</p>"},{"location":"reference/charts/funnel_charts/#funnel-tree","title":"Funnel Tree","text":"<p>Coming soon!</p>"},{"location":"reference/charts/funnel_charts/#funnel-sunburst","title":"Funnel Sunburst","text":"<p>Coming soon!</p>"},{"location":"reference/charts/funnel_charts/#flow-diagram","title":"Flow Diagram","text":"<p>Coming soon!</p>"},{"location":"reference/charts/funnel_charts/#arc-flow","title":"Arc Flow","text":"<p>Coming soon!</p>"},{"location":"reference/charts/maps/","title":"Maps","text":""},{"location":"reference/charts/maps/#tilemap","title":"Tilemap","text":""},{"location":"reference/charts/maps/#src.dx.plotting.dex.map_charts.tilemap","title":"<code>src.dx.plotting.dex.map_charts.tilemap(df, lat, lon, icon_opacity=1.0, icon_size=2, icon_size_scale='linear', stroke_color='#000000', stroke_width=2, label_column=None, tile_layer='streets', hover_cols=None, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX tilemap from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>lat</code> <code>str</code> <p>The column to use for the latitude values.</p> required <code>lon</code> <code>str</code> <p>The column to use for the longitude values.</p> required <code>icon_opacity</code> <code>float</code> <p>The opacity to use for the icon (<code>0.0</code> to <code>1.0</code>)</p> <code>1.0</code> <code>icon_size</code> <code>int</code> <p>Either: - int: a fixed size to use for the icon (<code>0</code> to <code>10</code>) - str: a column name to use for functional sizing</p> <code>2</code> <code>icon_size_scale</code> <code>DEXScale</code> <p>The scale to use for functional sizing (<code>\"linear\"</code> or <code>\"log\"</code>)</p> <code>'linear'</code> <code>stroke_color</code> <code>Color</code> <p>The color to use for the icon stroke.</p> <code>'#000000'</code> <code>stroke_width</code> <code>int</code> <p>The width to use for the icon stroke.</p> <code>2</code> <code>tile_layer</code> <code>str</code> <p>The type of tile layer to use. One of <code>\"streets\"</code>, <code>\"outdoors\"</code>, <code>\"light\"</code>, <code>\"dark\"</code>, or <code>\"satellite\"</code></p> <code>'streets'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/map_charts.py</code> <pre><code>def tilemap(\n    df,\n    lat: str,\n    lon: str,\n    icon_opacity: float = 1.0,\n    icon_size: int = 2,\n    icon_size_scale: options.DEXScale = \"linear\",\n    stroke_color: Color = \"#000000\",\n    stroke_width: int = 2,\n    label_column: Optional[str] = None,\n    tile_layer: str = \"streets\",\n    hover_cols: Optional[List[str]] = None,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXTilemapChartView]:\n    \"\"\"\n    Generates a DEX tilemap from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    lat: str\n        The column to use for the latitude values.\n    lon: str\n        The column to use for the longitude values.\n    icon_opacity: float\n        The opacity to use for the icon (`0.0` to `1.0`)\n    icon_size: Union[int, str]\n        Either:\n        - int: a fixed size to use for the icon (`0` to `10`)\n        - str: a column name to use for functional sizing\n    icon_size_scale: DEXScale\n        The scale to use for functional sizing (`\"linear\"` or `\"log\"`)\n    stroke_color: Color\n        The color to use for the icon stroke.\n    stroke_width: int\n        The width to use for the icon stroke.\n    tile_layer: str\n        The type of tile layer to use. One of `\"streets\"`, `\"outdoors\"`, `\"light\"`, `\"dark\"`, or `\"satellite\"`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([lat, lon], df.columns)\n\n    if isinstance(hover_cols, str):\n        hover_cols = [hover_cols]\n    if hover_cols is None:\n        hover_cols = df.columns\n    else:\n        raise_for_missing_columns(hover_cols, df.columns)\n\n    if label_column is not None:\n        raise_for_missing_columns(label_column, df.columns)\n\n    if isinstance(icon_size, str):\n        # referencing a column, treat as functional sizing\n\n        if icon_size not in df.columns:\n            # \"index\" was chosen but isn't in columns, which passes raise_for_missing_columns()\n            series = df.index\n        else:\n            series = df[icon_size]\n\n        series_min = series.min()\n        if str(icon_size_scale).lower() == \"log\":\n            series_min = 1\n\n        point_size_opts = {\n            \"mode\": \"functional\",\n            \"size\": 2,\n            \"met\": icon_size,\n            \"scale\": icon_size_scale,\n            \"min\": series_min,\n            \"max\": series.max(),\n            \"sizeMin\": 1,\n            \"sizeMax\": 10,\n        }\n    elif isinstance(icon_size, int):\n        # fixed sizing, shouldn't matter what we put in here\n        point_size_opts = {\n            \"mode\": \"fixed\",\n            \"size\": icon_size,\n            \"met\": str(lon),\n            \"scale\": icon_size_scale,\n            \"min\": df[str(lon)].min(),\n            \"max\": df[str(lon)].max(),\n            \"sizeMin\": 1,\n            \"sizeMax\": 10,\n        }\n    else:\n        raise ValueError(f\"`{type(icon_size)}` is not a valid type for `icon_size`.\")\n\n    # determine which columns are numeric and which ones are strings/mixed/etc\n    dimension_cols = [col for col in hover_cols if df[col].dtype == \"object\"]\n    metric_cols = [col for col in hover_cols if col not in dimension_cols]\n\n    layer_settings = {\n        \"lat_dim\": lat,\n        \"long_dim\": lon,\n        \"transparency\": icon_opacity,\n        \"size\": icon_size,\n        \"type\": \"point\",\n        \"stroke\": stroke_color,\n        \"stroke_width\": stroke_width,\n        \"point_size_opts\": point_size_opts,\n        \"hover_opts\": {\n            \"dims\": dimension_cols,\n            \"mets\": metric_cols,\n        },\n        \"tile_layer\": tile_layer,\n    }\n    if label_column is not None:\n        layer_settings[\"show_labels\"] = label_column\n\n    chart_settings = {\n        \"map_mode\": \"tile\",\n        \"layer_settings\": [layer_settings],\n    }\n    return handle_view(\n        df,\n        chart_mode=\"tilemap\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/maps/#choropleth","title":"Choropleth","text":"<p>Coming soon!</p>"},{"location":"reference/charts/part_to_whole_charts/","title":"Part-to-Whole Charts","text":""},{"location":"reference/charts/part_to_whole_charts/#pie","title":"Pie","text":""},{"location":"reference/charts/part_to_whole_charts/#src.dx.plotting.dex.basic_charts.pie","title":"<code>src.dx.plotting.dex.basic_charts.pie(df, y, split_slices_by=None, show_total=True, pie_label_type='rim', pie_label_contents='name', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX pie plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>y</code> <code>str</code> <p>The column to use for the slice size.</p> required <code>split_slices_by</code> <code>Optional[str]</code> <p>The column to use for splitting the slices. If not provided, slices will be split and sized by <code>y</code>.</p> <code>None</code> <code>show_total</code> <code>bool</code> <p>Whether to show the total.</p> <code>True</code> <code>pie_label_type</code> <code>DEXPieLabelType</code> <p>The pie label type to use:     - <code>\"rim\"</code> (default)     - <code>\"annotation\"</code>     - <code>\"center\"</code>     - <code>\"stem\"</code>     - <code>\"none\"</code></p> <code>'rim'</code> <code>pie_label_contents</code> <code>DEXPieLabelContents</code> <p>The pie label contents to use:     - <code>\"name\"</code> (default)     - <code>\"value\"</code>     - <code>\"percent\"</code>     - <code>\"name_value\"</code>     - <code>\"name_percent\"</code>     - <code>\"value_percent\"</code></p> <code>'name'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def pie(\n    df,\n    y: str,\n    split_slices_by: Optional[str] = None,\n    show_total: bool = True,\n    pie_label_type: options.DEXPieLabelType = \"rim\",\n    pie_label_contents: options.DEXPieLabelContents = \"name\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXPieChartView]:\n    \"\"\"\n    Generates a DEX pie plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    y: str\n        The column to use for the slice size.\n    split_slices_by: Optional[str]\n        The column to use for splitting the slices. If not provided, slices will be split and sized by `y`.\n    show_total: bool\n        Whether to show the total.\n    pie_label_type: DEXPieLabelType\n        The pie label type to use:\n            - `\"rim\"` (default)\n            - `\"annotation\"`\n            - `\"center\"`\n            - `\"stem\"`\n            - `\"none\"`\n    pie_label_contents: DEXPieLabelContents\n        The pie label contents to use:\n            - `\"name\"` (default)\n            - `\"value\"`\n            - `\"percent\"`\n            - `\"name_value\"`\n            - `\"name_percent\"`\n            - `\"value_percent\"`\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    if split_slices_by is None:\n        split_slices_by = y\n    raise_for_missing_columns([y, split_slices_by], df.columns)\n\n    chart_settings = {\n        \"dim1\": split_slices_by,\n        \"metric1\": y,\n        \"show_total\": show_total,\n        \"pie_label_type\": pie_label_type,\n        \"pie_label_contents\": pie_label_contents,\n    }\n    return handle_view(\n        df,\n        chart_mode=\"pie\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/part_to_whole_charts/#donut","title":"Donut","text":"<p>Coming soon!</p>"},{"location":"reference/charts/part_to_whole_charts/#sunburst","title":"Sunburst","text":"<p>Coming soon!</p>"},{"location":"reference/charts/part_to_whole_charts/#treemap","title":"Treemap","text":"<p>Coming soon!</p>"},{"location":"reference/charts/part_to_whole_charts/#partition","title":"Partition","text":"<p>Coming soon!</p>"},{"location":"reference/charts/relationship_charts/","title":"Relationship Charts","text":""},{"location":"reference/charts/relationship_charts/#force-directed-network","title":"Force-directed Network","text":"<p>Coming soon!</p>"},{"location":"reference/charts/relationship_charts/#sankey","title":"Sankey","text":"<p>Coming soon!</p>"},{"location":"reference/charts/relationship_charts/#arc-diagram","title":"Arc Diagram","text":"<p>Coming soon!</p>"},{"location":"reference/charts/relationship_charts/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Coming soon!</p>"},{"location":"reference/charts/relationship_charts/#dendrogram","title":"Dendrogram","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/","title":"Funnel Charts","text":""},{"location":"reference/charts/summary_charts/#big-number","title":"Big Number","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#wordcloud","title":"Wordcloud","text":""},{"location":"reference/charts/summary_charts/#src.dx.plotting.dex.basic_charts.wordcloud","title":"<code>src.dx.plotting.dex.basic_charts.wordcloud(df, word_column, size, text_format='sentence', word_rotation=None, random_coloring=False, return_view=False, **kwargs)</code>","text":"<p>Generates a DEX wordcloud from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>word_column</code> <code>str</code> <p>The column to use for the words in the cloud.</p> required <code>size</code> <code>str</code> <p>The column to use for the size of the words in the cloud.</p> required <code>text_format</code> <code>DEXTextDataFormat</code> <p>The format of the text data. Either <code>\"sentence\"</code> or <code>\"token\"</code>.</p> <code>'sentence'</code> <code>word_rotation</code> <code>Optional[DEXWordRotate]</code> <p>The rotation to use for the words in the cloud (<code>45</code>, <code>90</code>, <code>\"jitter\"</code>, or <code>None</code>).</p> <code>None</code> <code>random_coloring</code> <code>bool</code> <p>Whether to use random coloring for the words in the cloud.</p> <code>False</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def wordcloud(\n    df: pd.DataFrame,\n    word_column: str,\n    size: str,\n    text_format: options.DEXTextDataFormat = \"sentence\",\n    word_rotation: Optional[options.DEXWordRotate] = None,\n    random_coloring: bool = False,\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXWordcloudChartView]:\n    \"\"\"\n    Generates a DEX wordcloud from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    word_column: str\n        The column to use for the words in the cloud.\n    size: str\n        The column to use for the size of the words in the cloud.\n    text_format: DEXTextDataFormat\n        The format of the text data. Either `\"sentence\"` or `\"token\"`.\n    word_rotation: Optional[DEXWordRotate]\n        The rotation to use for the words in the cloud (`45`, `90`, `\"jitter\"`, or `None`).\n    random_coloring: bool\n        Whether to use random coloring for the words in the cloud.\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns([word_column, size], df.columns)\n\n    chart_settings = {\n        \"text_data_format\": text_format,\n        \"token_metric\": size,\n        \"word_data\": word_column,\n        \"word_color\": \"random\" if random_coloring else \"none\",\n        \"word_rotate\": word_rotation if word_rotation else \"none\",\n    }\n    return handle_view(\n        df,\n        chart_mode=\"wordcloud\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/summary_charts/#dimension-matrix","title":"Dimension Matrix","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#violin","title":"Violin","text":""},{"location":"reference/charts/summary_charts/#src.dx.plotting.dex.summary_charts.violin","title":"<code>src.dx.plotting.dex.summary_charts.violin(df, split_by, metric, bins=30, show_interquartile_range=False, column_sort_order='asc', column_sort_type='string', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX violin plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to plot.</p> required <code>split_by</code> <code>str</code> <p>The column to use for splitting the data.</p> required <code>metric</code> <code>str</code> <p>The column to use to show distribution and density.</p> required <code>bins</code> <code>int</code> <p>The number of bins to use for the violin plot.</p> <code>30</code> <code>show_interquartile_range</code> <code>bool</code> <p>Whether to show the interquartile range.</p> <code>False</code> <code>column_sort_order</code> <code>DEXSortColumnsByOrder</code> <p>The order to sort the columns by. (<code>\"asc\"</code> or <code>\"desc\"</code>)</p> <code>'asc'</code> <code>column_sort_type</code> <code>DEXSortColumnsByType</code> <p>The type of sorting to use. (<code>\"number\"</code>, <code>\"string\"</code>, or <code>\"date\"</code>)</p> <code>'string'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/summary_charts.py</code> <pre><code>def violin(\n    df: pd.DataFrame,\n    split_by: str,\n    metric: str,\n    bins: int = 30,\n    show_interquartile_range: bool = False,\n    column_sort_order: options.DEXSortColumnsByOrder = \"asc\",\n    column_sort_type: options.DEXSortColumnsByType = \"string\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXViolinChartView]:\n    \"\"\"\n    Generates a DEX violin plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    split_by: str\n        The column to use for splitting the data.\n    metric: str\n        The column to use to show distribution and density.\n    bins: int\n        The number of bins to use for the violin plot.\n    show_interquartile_range: bool\n        Whether to show the interquartile range.\n    column_sort_order: DEXSortColumnsByOrder\n        The order to sort the columns by. (`\"asc\"` or `\"desc\"`)\n    column_sort_type: DEXSortColumnsByType\n        The type of sorting to use. (`\"number\"`, `\"string\"`, or `\"date\"`)\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    if str(column_sort_order).lower() == \"asc\":\n        sort_order = \"desc\"\n    elif str(column_sort_order).lower() == \"desc\":\n        sort_order = \"asc\"\n    chart_params = dict(\n        summary_bins=bins,\n        sort_columns_by=f\"{sort_order}-col-{column_sort_type}\",\n        violin_iqr=show_interquartile_range,\n    )\n    return summary(\n        df,\n        split_by=split_by,\n        metric=metric,\n        summary_type=\"violin\",\n        chart_params=chart_params,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/summary_charts/#boxplot","title":"Boxplot","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#heatmap","title":"Heatmap","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#histogram","title":"Histogram","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#ridgeline","title":"Ridgeline","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#horizon","title":"Horizon","text":"<p>Coming soon!</p>"},{"location":"reference/charts/summary_charts/#hexbin","title":"Hexbin","text":"<p>Coming soon!</p>"},{"location":"reference/charts/time_series_charts/","title":"Time Series Charts","text":""},{"location":"reference/charts/time_series_charts/#line","title":"Line","text":""},{"location":"reference/charts/time_series_charts/#src.dx.plotting.dex.basic_charts.line","title":"<code>src.dx.plotting.dex.basic_charts.line(df, x, y, line_type='line', split_by=None, multi_axis=False, smoothing=None, use_count=False, bounding_type='absolute', zero_baseline=False, combination_mode='avg', return_view=False, **kwargs)</code>","text":"<p>Generates a DEX line plot from the given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>The DataFrame to plot.</p> required <code>x</code> <code>str</code> <p>The column to use for the x-axis.</p> required <code>y</code> <code>Union[List[str], str]</code> <p>The column(s) to use for the y-axis.</p> required <code>line_type</code> <code>DEXLineType</code> <p>The line type to use:     - <code>\"bumparea\"</code>     - <code>\"cumulative\"</code>     - <code>\"line\"</code> (default)     - <code>\"linepercent\"</code>     - <code>\"stackedarea\"</code>     - <code>\"stackedpercent\"</code></p> <code>'line'</code> <code>split_by</code> <code>Optional[str]</code> <p>The column to use for splitting the lines.</p> <code>None</code> <code>multi_axis</code> <code>bool</code> <p>Whether to use multiple y-axes.</p> <code>False</code> <code>smoothing</code> <code>Optional[DEXLineSmoothing]</code> <p>The line smoothing to use:     - <code>None</code> (default)     - <code>\"hourly\"</code>     - <code>\"daily\"</code>     - <code>\"weekly\"</code>     - <code>\"seven_day_moving_average\"</code>     - <code>\"monthly\"</code></p> <code>None</code> <code>use_count</code> <code>bool</code> <p>Whether to use the DEX_COUNT column for the y-axis.</p> <code>False</code> <code>bounding_type</code> <code>DEXBoundingType</code> <p>The bounding type to use:     - <code>\"absolute\"</code> (default)     - <code>\"relative\"</code></p> <code>'absolute'</code> <code>zero_baseline</code> <code>bool</code> <p>Whether to use a zero base line.</p> <code>False</code> <code>combination_mode</code> <code>DEXCombinationMode</code> <p>The combination mode to use (<code>\"avg\"</code>, <code>\"sum\"</code>, <code>\"min\"</code>, <code>\"median\"</code>, <code>\"max\"</code>, or <code>\"count\"</code>).</p> <code>'avg'</code> <code>return_view</code> <code>bool</code> <p>Whether to return a <code>DEXView</code> object instead of render.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the view metadata.</p> <code>{}</code> Source code in <code>src/dx/plotting/dex/basic_charts.py</code> <pre><code>def line(\n    df,\n    x: str,\n    y: Union[List[str], str],\n    line_type: options.DEXLineType = \"line\",\n    split_by: Optional[str] = None,\n    multi_axis: bool = False,\n    smoothing: Optional[options.DEXLineSmoothing] = None,\n    use_count: bool = False,\n    bounding_type: options.DEXBoundingType = \"absolute\",\n    zero_baseline: bool = False,\n    combination_mode: options.DEXCombinationMode = \"avg\",\n    return_view: bool = False,\n    **kwargs,\n) -&gt; Optional[DEXLineChartView]:\n    \"\"\"\n    Generates a DEX line plot from the given DataFrame.\n\n    Parameters\n    ----------\n    df: pd.DataFrame\n        The DataFrame to plot.\n    x: str\n        The column to use for the x-axis.\n    y: Union[List[str], str]\n        The column(s) to use for the y-axis.\n    line_type: DEXLineType\n        The line type to use:\n            - `\"bumparea\"`\n            - `\"cumulative\"`\n            - `\"line\"` (default)\n            - `\"linepercent\"`\n            - `\"stackedarea\"`\n            - `\"stackedpercent\"`\n    split_by: Optional[str]\n        The column to use for splitting the lines.\n    multi_axis: bool\n        Whether to use multiple y-axes.\n    smoothing: Optional[DEXLineSmoothing]\n        The line smoothing to use:\n            - `None` (default)\n            - `\"hourly\"`\n            - `\"daily\"`\n            - `\"weekly\"`\n            - `\"seven_day_moving_average\"`\n            - `\"monthly\"`\n    use_count: bool\n        Whether to use the DEX_COUNT column for the y-axis.\n    bounding_type: DEXBoundingType\n        The bounding type to use:\n            - `\"absolute\"` (default)\n            - `\"relative\"`\n    zero_baseline: bool\n        Whether to use a zero base line.\n    combination_mode: DEXCombinationMode\n        The combination mode to use (`\"avg\"`, `\"sum\"`, `\"min\"`, `\"median\"`, `\"max\"`, or `\"count\"`).\n    return_view: bool\n        Whether to return a `DEXView` object instead of render.\n    **kwargs\n        Additional keyword arguments to pass to the view metadata.\n    \"\"\"\n    raise_for_missing_columns(x, df.columns)\n\n    if isinstance(y, str):\n        y = [y]\n    raise_for_missing_columns(y, df.columns)\n    if use_count:\n        y.append(\"DEX_COUNT\")\n\n    if split_by is not None:\n        if str(split_by) not in df.columns:\n            raise ValueError(f\"Column '{split_by}' not found in DataFrame.\")\n\n    chart_settings = {\n        \"bounding_type\": bounding_type,\n        \"combination_mode\": combination_mode,\n        \"line_smoothing\": smoothing or \"none\",\n        \"line_type\": line_type,\n        \"multi_axis_line\": multi_axis,\n        \"selected_metrics\": y,\n        \"split_lines_by\": split_by,\n        \"timeseries_sort\": x,\n        \"zero_baseline\": zero_baseline,\n    }\n    logger.debug(f\"{chart_settings=}\")\n    return handle_view(\n        df,\n        chart_mode=\"line\",\n        chart=chart_settings,\n        return_view=return_view,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/charts/time_series_charts/#cumulative","title":"Cumulative","text":"<p>Coming soon!</p>"},{"location":"reference/charts/time_series_charts/#stacked-area","title":"Stacked Area","text":"<p>Coming soon!</p>"},{"location":"reference/charts/time_series_charts/#line-percent","title":"Line Percent","text":"<p>Coming soon!</p>"},{"location":"reference/charts/time_series_charts/#stacked-percent","title":"Stacked Percent","text":"<p>Coming soon!</p>"},{"location":"reference/charts/time_series_charts/#candlestick","title":"Candlestick","text":"<p>Coming soon!</p>"},{"location":"reference/datatypes/compatibility/","title":"Checking Compatibility","text":""},{"location":"reference/datatypes/compatibility/#src.dx.datatypes.compatibility.test_compatibility","title":"<code>src.dx.datatypes.compatibility.test_compatibility(value, as_dataframe=True)</code>","text":"<p>Convenience function to test the compatibility of a given object with the different steps involved with the dx display modes. - <code>pandas.io.json.build_table_schema</code> (https://github.com/pandas-dev/pandas/blob/main/pandas/io/json/_table_schema.py) - <code>jupyter_client.jsonutil.json_clean</code> (https://github.com/jupyter/jupyter_client/blob/main/jupyter_client/jsonutil.py) - <code>duckdb conn.register</code> - final dx output type</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to test compatibility with.</p> required <code>as_dataframe</code> <code>bool</code> <p>Whether to return the results as a pandas DataFrame (if <code>True</code>), or as a dictionary (if <code>False</code>)</p> <code>True</code> Source code in <code>src/dx/datatypes/compatibility.py</code> <pre><code>def test_compatibility(value: Any, as_dataframe: bool = True) -&gt; dict:\n    \"\"\"\n    Convenience function to test the compatibility of a given object\n    with the different steps involved with the dx display modes.\n    - `pandas.io.json.build_table_schema` (https://github.com/pandas-dev/pandas/blob/main/pandas/io/json/_table_schema.py)\n    - `jupyter_client.jsonutil.json_clean` (https://github.com/jupyter/jupyter_client/blob/main/jupyter_client/jsonutil.py)\n    - `duckdb conn.register`\n    - final dx output type\n\n    Parameters\n    ----------\n    value: Any\n        The value to test compatibility with.\n    as_dataframe: bool\n        Whether to return the results as a pandas DataFrame (if `True`),\n        or as a dictionary (if `False`)\n    \"\"\"\n    result = {}\n    result.update(test_build_table_schema(value))\n    result.update(test_json_clean(value))\n    result.update(test_db_write(value))\n    result.update(test_dx_handling(value))\n    if as_dataframe:\n        return pd.DataFrame(result).transpose()\n    return result\n</code></pre>"},{"location":"reference/datatypes/compatibility/#src.dx.datatypes.compatibility.test_build_table_schema","title":"<code>src.dx.datatypes.compatibility.test_build_table_schema(value, as_dataframe=False)</code>","text":"<p>Convenience function to test the compatibility of a given object with the pandas.io.json.build_table_schema function, which is called to set up the initial column schema during dx formatting.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to test compatibility with.</p> required <code>as_dataframe</code> <code>bool</code> <p>Whether to return the results as a pandas DataFrame (if <code>True</code>), or as a dictionary (if <code>False</code>)</p> <code>False</code> Source code in <code>src/dx/datatypes/compatibility.py</code> <pre><code>def test_build_table_schema(value: Any, as_dataframe: bool = False) -&gt; dict:\n    \"\"\"\n    Convenience function to test the compatibility of a given object\n    with the pandas.io.json.build_table_schema function, which\n    is called to set up the initial column schema during dx formatting.\n\n    Parameters\n    ----------\n    value: Any\n        The value to test compatibility with.\n    as_dataframe: bool\n        Whether to return the results as a pandas DataFrame (if `True`),\n        or as a dictionary (if `False`)\n    \"\"\"\n    df = pd.DataFrame({\"test\": [value]})\n    result = {}\n\n    try:\n        schema = build_table_schema(df, index=False)\n        fields = schema[\"fields\"]\n        field_type = [\n            field_schema[\"type\"] for field_schema in fields if field_schema[\"name\"] == \"test\"\n        ][0]\n        result[\"pandas.io.json.build_table_schema\"] = {\n            \"success\": True,\n            \"type\": field_type,\n        }\n    except Exception as e:\n        result[\"pandas.io.json.build_table_schema\"] = {\n            \"error\": str(e),\n            \"success\": False,\n            \"traceback\": traceback.format_exc(),\n        }\n\n    if as_dataframe:\n        return pd.DataFrame(result).transpose()\n    return result\n</code></pre>"},{"location":"reference/datatypes/compatibility/#src.dx.datatypes.compatibility.test_json_clean","title":"<code>src.dx.datatypes.compatibility.test_json_clean(value, as_dataframe=False)</code>","text":"<p>Convenience function to test the compatibility of a given object with the jupyter_client.jsonutil.json_clean function, which is called during IPython.display after dx formatting.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to test compatibility with.</p> required <code>as_dataframe</code> <code>bool</code> <p>Whether to return the results as a pandas DataFrame (if <code>True</code>), or as a dictionary (if <code>False</code>)</p> <code>False</code> Source code in <code>src/dx/datatypes/compatibility.py</code> <pre><code>def test_json_clean(value: Any, as_dataframe: bool = False) -&gt; dict:\n    \"\"\"\n    Convenience function to test the compatibility of a given object\n    with the jupyter_client.jsonutil.json_clean function, which\n    is called during IPython.display after dx formatting.\n\n    Parameters\n    ----------\n    value: Any\n        The value to test compatibility with.\n    as_dataframe: bool\n        Whether to return the results as a pandas DataFrame (if `True`),\n        or as a dictionary (if `False`)\n    \"\"\"\n    df = pd.DataFrame({\"test\": [value]})\n    result = {}\n\n    try:\n        from jupyter_client.jsonutil import json_clean\n\n        clean_json = json_clean(df.to_dict(\"records\"))\n        clean_json_value = clean_json[0][\"test\"]\n        result[\"jupyter_client.jsonutil.json_clean\"] = {\n            \"success\": True,\n            \"type\": type(clean_json_value),\n            \"value\": clean_json_value,\n        }\n    except Exception as e:\n        result[\"jupyter_client.jsonutil.json_clean\"] = {\n            \"error\": str(e),\n            \"success\": False,\n            \"traceback\": traceback.format_exc(),\n        }\n\n    if as_dataframe:\n        return pd.DataFrame(result).transpose()\n    return result\n</code></pre>"},{"location":"reference/datatypes/compatibility/#src.dx.datatypes.compatibility.test_db_write","title":"<code>src.dx.datatypes.compatibility.test_db_write(value, as_dataframe=False)</code>","text":"<p>Convenience function to test the compatibility of a given object inside a pandas DataFrame during registration with a duckdb connection, which is used during Datalink-enabled dataframe tracking for push-down filtering.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to test compatibility with.</p> required <code>as_dataframe</code> <code>bool</code> <p>Whether to return the results as a pandas DataFrame (if <code>True</code>), or as a dictionary (if <code>False</code>)</p> <code>False</code> Source code in <code>src/dx/datatypes/compatibility.py</code> <pre><code>def test_db_write(value: Any, as_dataframe: bool = False) -&gt; dict:\n    \"\"\"\n    Convenience function to test the compatibility of a given object\n    inside a pandas DataFrame during registration with a duckdb connection,\n    which is used during Datalink-enabled dataframe tracking for\n    push-down filtering.\n\n    Parameters\n    ----------\n    value: Any\n        The value to test compatibility with.\n    as_dataframe: bool\n        Whether to return the results as a pandas DataFrame (if `True`),\n        or as a dictionary (if `False`)\n    \"\"\"\n    from dx.utils.tracking import get_db_connection  # circular import\n\n    df = pd.DataFrame({\"test\": [value]})\n    result = {}\n\n    db_connection = get_db_connection()\n    try:\n        db_connection.register(\"test\", df)\n        db_df = db_connection.execute(\"SELECT * FROM test\").df()\n        db_df_value = db_df.iloc[0][\"test\"]\n        result[\"duckdb.conn.register\"] = {\n            \"type\": type(db_df_value),\n            \"success\": True,\n            \"value\": db_df_value,\n        }\n    except Exception as e:\n        result[\"duckdb.conn.register\"] = {\n            \"error\": str(e),\n            \"success\": False,\n            \"traceback\": traceback.format_exc(),\n        }\n\n    if as_dataframe:\n        return pd.DataFrame(result).transpose()\n    return result\n</code></pre>"},{"location":"reference/datatypes/compatibility/#src.dx.datatypes.compatibility.test_dx_handling","title":"<code>src.dx.datatypes.compatibility.test_dx_handling(value, as_dataframe=False)</code>","text":"<p>Convenience function to test the compatibility of a given object inside a pandas DataFrame through the entire dx formatting and data type handling process.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to test compatibility with.</p> required <code>as_dataframe</code> <code>bool</code> <p>Whether to return the results as a pandas DataFrame (if <code>True</code>), or as a dictionary (if <code>False</code>)</p> <code>False</code> Source code in <code>src/dx/datatypes/compatibility.py</code> <pre><code>def test_dx_handling(value: Any, as_dataframe: bool = False) -&gt; dict:\n    \"\"\"\n    Convenience function to test the compatibility of a given object\n    inside a pandas DataFrame through the entire dx formatting\n    and data type handling process.\n\n    Parameters\n    ----------\n    value : Any\n        The value to test compatibility with.\n    as_dataframe : bool, optional\n        Whether to return the results as a pandas DataFrame (if `True`),\n        or as a dictionary (if `False`)\n    \"\"\"\n    from dx.formatters.main import handle_format  # circular import\n\n    df = pd.DataFrame({\"test\": [value]})\n    result = {}\n\n    try:\n        payload, _ = handle_format(df, with_ipython_display=False)\n\n        if settings.DISPLAY_MODE == \"simple\":\n            dx_value = payload[settings.MEDIA_TYPE][\"data\"][0][\"test\"]\n        if settings.DISPLAY_MODE == \"enhanced\":\n            dx_value = payload[settings.MEDIA_TYPE][\"data\"][0][0]\n\n        dx_schema_fields = payload[settings.MEDIA_TYPE][\"schema\"][\"fields\"]\n        # should only be two fields here by default: `index` and `test`\n        # but we wanted to run the entire formatting process, which doesn't need\n        # an option to disable `index` from being included\n        dx_schema_type = [field[\"type\"] for field in dx_schema_fields if field[\"name\"] == \"test\"][0]\n\n        result[\"dx.handle_format\"] = {\n            \"type\": type(dx_value),\n            \"success\": True,\n            \"value\": dx_value,\n            \"schema_type\": dx_schema_type,\n        }\n    except Exception as e:\n        result[\"dx.handle_format\"] = {\n            \"error\": str(e),\n            \"success\": False,\n            \"traceback\": traceback.format_exc(),\n        }\n\n    if as_dataframe:\n        return pd.DataFrame(result).transpose()\n    return result\n</code></pre>"},{"location":"reference/datatypes/dataframes/","title":"DataFrames","text":""},{"location":"reference/datatypes/dataframes/#src.dx.datatypes.main.quick_random_dataframe","title":"<code>src.dx.datatypes.main.quick_random_dataframe(num_rows=5, num_cols=2, dtype='float', factor=1.0)</code>","text":"<p>Convenience function wrapping <code>pd.DataFrame(np.random.rand( num_rows, num_columns ))</code> to create a dataframe of random 0.0-1.0 values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> <code>5</code> <code>num_cols</code> <code>int</code> <p>Number of columns to generate</p> <code>2</code> <code>dtype</code> <code>str</code> <p>Data type to use for the generated dataframe values.</p> <code>'float'</code> <code>factor</code> <code>float</code> <p>Factor to multiply the generated values by.</p> <code>1.0</code> Source code in <code>src/dx/datatypes/main.py</code> <pre><code>def quick_random_dataframe(\n    num_rows: int = 5,\n    num_cols: int = 2,\n    dtype: str = \"float\",\n    factor: float = 1.0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Convenience function wrapping `pd.DataFrame(np.random.rand( num_rows, num_columns ))`\n    to create a dataframe of random 0.0-1.0 values.\n\n    Parameters\n    ----------\n    num_rows : int\n        Number of rows to generate\n    num_cols : int\n        Number of columns to generate\n    dtype : str\n        Data type to use for the generated dataframe values.\n    factor : float\n        Factor to multiply the generated values by.\n    \"\"\"\n    data = np.random.rand(num_rows, num_cols) * factor\n    df = pd.DataFrame(data)\n    return df.astype(dtype, errors=\"ignore\")\n</code></pre>"},{"location":"reference/datatypes/dataframes/#src.dx.datatypes.main.random_dataframe","title":"<code>src.dx.datatypes.main.random_dataframe(num_rows=5, dtype_column=True, integer_column=True, float_column=True, bool_column=True, decimal_column=False, datetime_column=True, datetimetz_column=False, date_column=False, time_column=False, time_delta_column=False, time_period_column=False, time_interval_column=False, text_column=False, keyword_column=True, dict_column=False, list_column=False, nested_tabular_column=False, lat_float_column=False, lon_float_column=False, latlon_point_column=False, filled_geojson_column=False, exterior_geojson_column=False, bytes_column=True, ipv4_address_column=False, ipv6_address_column=False, complex_number_column=False, uuid4_column=False)</code>","text":"<p>Convenience function to generate a dataframe of <code>num_rows</code> length with randomly-generated values of mixed data types.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> <code>5</code> <code>dtype_column</code> <code>bool</code> <p>Whether to include a column of <code>type</code> values</p> <code>True</code> <code>integer_column</code> <code>bool</code> <p>Whether to include a column of <code>integer</code> values</p> <code>True</code> <code>float_column</code> <code>bool</code> <p>Whether to include a column of <code>float</code> values</p> <code>True</code> <code>bool_column</code> <code>bool</code> <p>Whether to include a column of <code>bool</code> values</p> <code>True</code> <code>decimal_column</code> <code>bool</code> <p>Whether to include a column of <code>decimal.Decimal</code> values</p> <code>False</code> <code>datetime_column</code> <code>bool</code> <p>Whether to include a column of <code>datetime.datetime</code> values</p> <code>True</code> <code>datetimetz_column</code> <code>bool</code> <p>Whether to include a column of <code>datetime.datetime</code> values with timezones</p> <code>False</code> <code>date_column</code> <code>bool</code> <p>Whether to include a column of <code>datetime.date</code> values</p> <code>False</code> <code>time_column</code> <code>bool</code> <p>Whether to include a column of <code>datetime.time</code> values</p> <code>False</code> <code>time_delta_column</code> <code>bool</code> <p>Whether to include a column of <code>pd.Timedelta</code> values</p> <code>False</code> <code>time_period_column</code> <code>bool</code> <p>Whether to include a column of <code>pd.Period</code> values</p> <code>False</code> <code>time_interval_column</code> <code>bool</code> <p>Whether to include a column of <code>pd.Interval</code> values</p> <code>False</code> <code>text_column</code> <code>bool</code> <p>Whether to include a column of long <code>str</code> values using <code>faker</code></p> <code>False</code> <code>keyword_column</code> <code>bool</code> <p>Whether to include a column of short <code>str</code> values</p> <code>True</code> <code>dict_column</code> <code>bool</code> <p>Whether to include a column of <code>dict</code> values</p> <code>False</code> <code>list_column</code> <code>bool</code> <p>Whether to include a column of <code>list</code> values</p> <code>False</code> <code>nested_tabular_column</code> <code>bool</code> <p>Whether to include a column of <code>list</code> values with nested dictionaries</p> <code>False</code> <code>lat_float_column</code> <code>bool</code> <p>Whether to include a column of <code>float</code> values representing latitudes</p> <code>False</code> <code>lon_float_column</code> <code>bool</code> <p>Whether to include a column of <code>float</code> values representing longitudes</p> <code>False</code> <code>latlon_point_column</code> <code>bool</code> <p>Whether to include a <code>geopandas.GeoSeries</code> of <code>shapely.geometry.Point</code> values (requires <code>geopandas</code> to be installed)</p> <code>False</code> <code>filled_geojson_column</code> <code>bool</code> <p>Whether to include a <code>geopandas.GeoSeries</code> of circular <code>shapely.geometry.Polygon</code> values (requires <code>geopandas</code> to be installed)</p> <code>False</code> <code>exterior_geojson_column</code> <code>bool</code> <p>Whether to include a <code>geopandas.GeoSeries</code> of rectangular <code>shapely.geometry.LineString</code> values (requires <code>geopandas</code> to be installed)</p> <code>False</code> <code>bytes_column</code> <code>bool</code> <p>Whether to include a column of <code>bytes</code> values</p> <code>True</code> <code>ipv4_address_column</code> <code>bool</code> <p>Whether to include a column of <code>ipaddress.IPv4Address</code> values</p> <code>False</code> <code>ipv6_address_column</code> <code>bool</code> <p>Whether to include a column of <code>ipaddress.IPv6Address</code> values</p> <code>False</code> <code>complex_number_column</code> <code>bool</code> <p>Whether to include a column of <code>complex</code> values</p> <code>False</code> <code>uuid4_column</code> <code>bool</code> <p>Whether to include a column of <code>uuid.UUID</code> values</p> <code>False</code> Source code in <code>src/dx/datatypes/main.py</code> <pre><code>def random_dataframe(\n    num_rows: int = 5,\n    dtype_column: bool = True,\n    integer_column: bool = True,\n    float_column: bool = True,\n    bool_column: bool = True,\n    decimal_column: bool = False,\n    datetime_column: bool = True,\n    datetimetz_column: bool = False,\n    date_column: bool = False,\n    time_column: bool = False,\n    time_delta_column: bool = False,\n    time_period_column: bool = False,\n    time_interval_column: bool = False,\n    text_column: bool = False,\n    keyword_column: bool = True,\n    dict_column: bool = False,\n    list_column: bool = False,\n    nested_tabular_column: bool = False,\n    lat_float_column: bool = False,\n    lon_float_column: bool = False,\n    latlon_point_column: bool = False,\n    filled_geojson_column: bool = False,\n    exterior_geojson_column: bool = False,\n    bytes_column: bool = True,\n    ipv4_address_column: bool = False,\n    ipv6_address_column: bool = False,\n    complex_number_column: bool = False,\n    uuid4_column: bool = False,\n):  # noqa: C901\n    \"\"\"\n    Convenience function to generate a dataframe of `num_rows` length\n    with randomly-generated values of mixed data types.\n\n    Parameters\n    ----------\n    num_rows : int\n        Number of rows to generate\n    dtype_column : bool\n        Whether to include a column of `type` values\n    integer_column : bool\n        Whether to include a column of `integer` values\n    float_column : bool\n        Whether to include a column of `float` values\n    bool_column : bool\n        Whether to include a column of `bool` values\n    decimal_column : bool\n        Whether to include a column of `decimal.Decimal` values\n    datetime_column : bool\n        Whether to include a column of `datetime.datetime` values\n    datetimetz_column : bool\n        Whether to include a column of `datetime.datetime` values with timezones\n    date_column : bool\n        Whether to include a column of `datetime.date` values\n    time_column : bool\n        Whether to include a column of `datetime.time` values\n    time_delta_column : bool\n        Whether to include a column of `pd.Timedelta` values\n    time_period_column : bool\n        Whether to include a column of `pd.Period` values\n    time_interval_column : bool\n        Whether to include a column of `pd.Interval` values\n    text_column : bool\n        Whether to include a column of long `str` values using `faker`\n    keyword_column : bool\n        Whether to include a column of short `str` values\n    dict_column : bool\n        Whether to include a column of `dict` values\n    list_column : bool\n        Whether to include a column of `list` values\n    nested_tabular_column : bool\n        Whether to include a column of `list` values with nested dictionaries\n    lat_float_column : bool\n        Whether to include a column of `float` values representing latitudes\n    lon_float_column : bool\n        Whether to include a column of `float` values representing longitudes\n    latlon_point_column : bool\n        Whether to include a `geopandas.GeoSeries` of `shapely.geometry.Point` values (requires `geopandas` to be installed)\n    filled_geojson_column : bool\n        Whether to include a `geopandas.GeoSeries` of circular `shapely.geometry.Polygon` values (requires `geopandas` to be installed)\n    exterior_geojson_column : bool\n        Whether to include a `geopandas.GeoSeries` of rectangular `shapely.geometry.LineString` values (requires `geopandas` to be installed)\n    bytes_column : bool\n        Whether to include a column of `bytes` values\n    ipv4_address_column : bool\n        Whether to include a column of `ipaddress.IPv4Address` values\n    ipv6_address_column : bool\n        Whether to include a column of `ipaddress.IPv6Address` values\n    complex_number_column : bool\n        Whether to include a column of `complex` values\n    uuid4_column : bool\n        Whether to include a column of `uuid.UUID` values\n    \"\"\"\n    df = pd.DataFrame(index=list(range(num_rows)))\n\n    if dtype_column:\n        df[\"dtype_column\"] = misc.generate_dtype_series(num_rows)\n\n    if bool_column:\n        df[\"bool_column\"] = misc.generate_boolean_series(num_rows)\n\n    # numeric columns\n    if integer_column:\n        df[\"integer_column\"] = numeric.generate_integer_series(num_rows)\n\n    if float_column:\n        df[\"float_column\"] = numeric.generate_float_series(num_rows)\n\n    if decimal_column:\n        df[\"decimal_column\"] = numeric.generate_decimal_series(num_rows)\n\n    if complex_number_column:\n        df[\"complex_number_column\"] = numeric.generate_complex_number_series(num_rows)\n\n    # date/time columns\n    if datetime_column:\n        df[\"datetime_column\"] = date_time.generate_datetime_series(num_rows)\n\n    if datetimetz_column:\n        df[\"datetimetz_column\"] = date_time.generate_datetimetz_series(num_rows)\n\n    if date_column:\n        df[\"date_column\"] = date_time.generate_date_series(num_rows)\n\n    if time_column:\n        df[\"time_column\"] = date_time.generate_time_series(num_rows)\n\n    if time_delta_column:\n        df[\"time_delta_column\"] = date_time.generate_time_delta_series(num_rows)\n\n    if time_period_column:\n        df[\"time_period_column\"] = date_time.generate_time_period_series(num_rows)\n\n    if time_interval_column:\n        df[\"time_interval_column\"] = date_time.generate_time_interval_series(num_rows)\n\n    # string columns\n    if text_column:\n        df[\"text_column\"] = text.generate_text_series(num_rows)\n\n    if keyword_column:\n        df[\"keyword_column\"] = text.generate_keyword_series(num_rows)\n\n    # container columns\n    if dict_column:\n        df[\"dict_column\"] = misc.generate_dict_series(num_rows)\n\n    if list_column:\n        df[\"list_column\"] = misc.generate_list_series(num_rows)\n\n    if nested_tabular_column:\n        df[\"nested_tabular_column\"] = generate_nested_tabular_series(\n            num_rows,\n            float_column=True,\n            keyword_column=True,\n        )\n\n    # geopandas/shapely columns\n    if lat_float_column:\n        df[\"lat_float_column\"] = geometry.generate_lat_float_series(num_rows)\n\n    if lon_float_column:\n        df[\"lon_float_column\"] = geometry.generate_lon_float_series(num_rows)\n\n    if latlon_point_column:\n        df[\"latlon_point_column\"] = geometry.generate_latlon_series(num_rows)\n\n    if filled_geojson_column:\n        df[\"filled_geojson_column\"] = geometry.generate_filled_geojson_series(num_rows)\n\n    if exterior_geojson_column:\n        df[\"exterior_geojson_column\"] = geometry.generate_exterior_bounds_geojson_series(num_rows)\n\n    # extras\n    if bytes_column:\n        df[\"bytes_column\"] = misc.generate_bytes_series(num_rows)\n\n    if ipv4_address_column:\n        df[\"ipv4_address_column\"] = misc.generate_ipv4_series(num_rows)\n\n    if ipv6_address_column:\n        df[\"ipv6_address_column\"] = misc.generate_ipv6_series(num_rows)\n\n    if uuid4_column:\n        df[\"uuid4_column\"] = misc.generate_uuid4_series(num_rows)\n\n    return df\n</code></pre>"},{"location":"reference/datatypes/datetime/","title":"Datetime","text":""},{"location":"reference/datatypes/datetime/#src.dx.datatypes.date_time.generate_datetime_series","title":"<code>src.dx.datatypes.date_time.generate_datetime_series(num_rows)</code>","text":"<p>Generate a series of random <code>datetime.datetime</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/date_time.py</code> <pre><code>def generate_datetime_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `datetime.datetime` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [\n            (\n                pd.Timestamp(\"now\") + pd.Timedelta(f\"{np.random.randint(-1000, 1000)} hours\")\n            ).to_pydatetime()\n            for _ in range(num_rows)\n        ]\n    )\n</code></pre>"},{"location":"reference/datatypes/datetime/#src.dx.datatypes.date_time.generate_date_series","title":"<code>src.dx.datatypes.date_time.generate_date_series(num_rows)</code>","text":"<p>Generate a series of random <code>datetime.date</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/date_time.py</code> <pre><code>def generate_date_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `datetime.date` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [\n            (pd.Timestamp(\"now\") + pd.Timedelta(f\"{np.random.randint(-1000, 1000)} hours\")).date()\n            for _ in range(num_rows)\n        ]\n    )\n</code></pre>"},{"location":"reference/datatypes/datetime/#src.dx.datatypes.date_time.generate_time_series","title":"<code>src.dx.datatypes.date_time.generate_time_series(num_rows)</code>","text":"<p>Generate a series of random <code>datetime.time</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/date_time.py</code> <pre><code>def generate_time_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `datetime.time` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [\n            (pd.Timestamp(\"now\") + pd.Timedelta(f\"{np.random.randint(-1000, 1000)} hours\")).time()\n            for _ in range(num_rows)\n        ]\n    )\n</code></pre>"},{"location":"reference/datatypes/datetime/#src.dx.datatypes.date_time.generate_time_period_series","title":"<code>src.dx.datatypes.date_time.generate_time_period_series(num_rows)</code>","text":"<p>Generate a series of random <code>pd.Period</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/date_time.py</code> <pre><code>def generate_time_period_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `pd.Period` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [\n            (\n                pd.Timestamp(\"now\") + pd.Timedelta(f\"{np.random.randint(-1000, 1000)} hours\")\n            ).to_period(freq=\"W\")\n            for _ in range(num_rows)\n        ]\n    )\n</code></pre>"},{"location":"reference/datatypes/datetime/#src.dx.datatypes.date_time.generate_time_interval_series","title":"<code>src.dx.datatypes.date_time.generate_time_interval_series(num_rows)</code>","text":"<p>Generate a series of random <code>pd.Interval</code> values with <code>pd.Timestamp</code> left/right values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/date_time.py</code> <pre><code>def generate_time_interval_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `pd.Interval` values with `pd.Timestamp` left/right values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [\n            pd.Interval(\n                pd.Timestamp(\"now\") + pd.Timedelta(f\"{np.random.randint(-1000, 0)} hours\"),\n                pd.Timestamp(\"now\") + pd.Timedelta(f\"{np.random.randint(0, 1000)} hours\"),\n            )\n            for _ in range(num_rows)\n        ]\n    )\n</code></pre>"},{"location":"reference/datatypes/datetime/#src.dx.datatypes.date_time.generate_time_delta_series","title":"<code>src.dx.datatypes.date_time.generate_time_delta_series(num_rows)</code>","text":"<p>Generate a series of random <code>pd.Timedelta</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/date_time.py</code> <pre><code>def generate_time_delta_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `pd.Timedelta` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [pd.Timedelta(f\"{np.random.randint(-1000, 1000)} hours\") for _ in range(num_rows)]\n    )\n</code></pre>"},{"location":"reference/datatypes/geometry/","title":"Geospatial/Geometry","text":""},{"location":"reference/datatypes/geometry/#src.dx.datatypes.geometry.generate_lat_float_series","title":"<code>src.dx.datatypes.geometry.generate_lat_float_series(num_rows)</code>","text":"<p>Generate a series of random <code>float</code> values representing latitude values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/geometry.py</code> <pre><code>def generate_lat_float_series(num_rows: int):\n    \"\"\"\n    Generate a series of random `float` values representing latitude values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series([random.randint(-90, 89) + np.random.rand() for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/geometry/#src.dx.datatypes.geometry.generate_lon_float_series","title":"<code>src.dx.datatypes.geometry.generate_lon_float_series(num_rows)</code>","text":"<p>Generate a series of random <code>float</code> values representing longitude values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/geometry.py</code> <pre><code>def generate_lon_float_series(num_rows: int):\n    \"\"\"\n    Generate a series of random `float` values representing longitude values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series([random.randint(-180, 179) + np.random.rand() for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/geometry/#src.dx.datatypes.geometry.generate_latlon_series","title":"<code>src.dx.datatypes.geometry.generate_latlon_series(num_rows)</code>","text":"<p>Generate a series of <code>shapely.geometry.Point</code>s with latitude and longitude values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/geometry.py</code> <pre><code>def generate_latlon_series(num_rows: int):\n    \"\"\"\n    Generate a series of `shapely.geometry.Point`s with latitude and longitude values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    if not geopandas_installed():\n        logger.warning(\"geopandas is not installed, skipping generate_latlon_series\")\n        return np.nan\n\n    lats = [random.randint(-90, 89) + np.random.rand() for _ in range(num_rows)]\n    lons = [random.randint(-180, 179) + np.random.rand() for _ in range(num_rows)]\n    return gpd.GeoSeries(gpd.points_from_xy(lons, lats))\n</code></pre>"},{"location":"reference/datatypes/geometry/#src.dx.datatypes.geometry.generate_filled_geojson_series","title":"<code>src.dx.datatypes.geometry.generate_filled_geojson_series(num_rows, existing_latlon_series=None)</code>","text":"<p>Generate a series of <code>shapely.geometry.Polygon</code> values by creating <code>shapely.geometry.Point</code> values and applying a randomized <code>.buffer()</code> on them, resulting in circular filled <code>Polygon</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>existing_latlon_series</code> <code>Optional[Series]</code> <p>If provided, use this series of <code>shapely.geometry.Point</code> values</p> <code>None</code> Source code in <code>src/dx/datatypes/geometry.py</code> <pre><code>def generate_filled_geojson_series(\n    num_rows: int,\n    existing_latlon_series: Optional[pd.Series] = None,\n):\n    \"\"\"\n    Generate a series of `shapely.geometry.Polygon` values by\n    creating `shapely.geometry.Point` values and applying a randomized\n    `.buffer()` on them, resulting in circular filled `Polygon` objects.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    existing_latlon_series: Optional[pd.Series]\n        If provided, use this series of `shapely.geometry.Point` values\n    \"\"\"\n    if not geopandas_installed():\n        logger.warning(\"geopandas is not installed, skipping filled_geojson_column\")\n        return np.nan\n\n    if existing_latlon_series is None:\n        latlon_series = generate_latlon_series(num_rows)\n    else:\n        latlon_series = existing_latlon_series\n    buffer_series = gpd.GeoSeries(latlon_series).apply(lambda x: x.buffer(np.random.rand()))\n    return gpd.GeoSeries(buffer_series)\n</code></pre>"},{"location":"reference/datatypes/geometry/#src.dx.datatypes.geometry.generate_exterior_bounds_geojson_series","title":"<code>src.dx.datatypes.geometry.generate_exterior_bounds_geojson_series(num_rows, existing_latlon_series=None)</code>","text":"<p>Generate a series of <code>shapely.geometry.Polygon</code> values by create <code>shapely.geometry.Point</code> values, applying a randomized <code>.buffer()</code> on them, and getting the exterior of the resulting object's <code>.envelope</code>, resulting in rectangular <code>LineString</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>existing_latlon_series</code> <code>Optional[Series]</code> <p>If provided, use this series of <code>shapely.geometry.Point</code> values</p> <code>None</code> Source code in <code>src/dx/datatypes/geometry.py</code> <pre><code>def generate_exterior_bounds_geojson_series(\n    num_rows: int,\n    existing_latlon_series: Optional[pd.Series] = None,\n):\n    \"\"\"\n    Generate a series of `shapely.geometry.Polygon` values by\n    create `shapely.geometry.Point` values, applying a randomized `.buffer()`\n    on them, and getting the exterior of the resulting object's `.envelope`,\n    resulting in rectangular `LineString` objects.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    existing_latlon_series: Optional[pd.Series]\n        If provided, use this series of `shapely.geometry.Point` values\n    \"\"\"\n    if not geopandas_installed():\n        logger.warning(\"geopandas is not installed, skipping exterior_geojson_column\")\n        return np.nan\n\n    if existing_latlon_series is None:\n        latlon_series = generate_latlon_series(num_rows)\n    else:\n        latlon_series = existing_latlon_series\n\n    envelope_series = gpd.GeoSeries(latlon_series).apply(\n        lambda x: x.buffer(np.random.rand()).envelope.exterior\n    )\n    return gpd.GeoSeries(envelope_series)\n</code></pre>"},{"location":"reference/datatypes/misc/","title":"Misc","text":""},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_boolean_series","title":"<code>src.dx.datatypes.misc.generate_boolean_series(num_rows)</code>","text":"<p>Generate a series of random <code>boolean</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_boolean_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `boolean` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series([random.choice([True, False]) for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_bytes_series","title":"<code>src.dx.datatypes.misc.generate_bytes_series(num_rows, n_bytes=10)</code>","text":"<p>Generate a series of random <code>bytes</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>n_bytes</code> <code>int</code> <p>Number of bytes to generate per row</p> <code>10</code> Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_bytes_series(num_rows: int, n_bytes: int = 10) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `bytes` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    n_bytes: int\n        Number of bytes to generate per row\n    \"\"\"\n    return pd.Series([np.random.bytes(n_bytes) for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_dict_series","title":"<code>src.dx.datatypes.misc.generate_dict_series(num_rows)</code>","text":"<p>Generate a series of random <code>dict</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_dict_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `dict` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [\n            {\n                \"nested_property\": random.choice([\"apple\", \"banana\", \"orange\", \"pear\"]),\n                \"nested_other_property\": random.randint(0, 10),\n                \"nested_bool\": random.choice([True, False]),\n            }\n            for _ in range(num_rows)\n        ]\n    )\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_dtype_series","title":"<code>src.dx.datatypes.misc.generate_dtype_series(num_rows)</code>","text":"<p>Generate a series of random <code>type</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_dtype_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `type` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [random.choice([float, int, str, bool, set, tuple, dict, list]) for _ in range(num_rows)]\n    )\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_list_series","title":"<code>src.dx.datatypes.misc.generate_list_series(num_rows)</code>","text":"<p>Generate a series of random <code>list</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_list_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `list` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series([[random.randint(0, 5) for _ in range(5)] for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_ipv4_series","title":"<code>src.dx.datatypes.misc.generate_ipv4_series(num_rows)</code>","text":"<p>Generate a series of random <code>ipaddress.IPv4Address</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_ipv4_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `ipaddress.IPv4Address` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n\n    def random_ipv4():\n        address_str = \".\".join(str(random.randint(0, 255)) for _ in range(4))\n        return ipaddress.ip_address(address_str)\n\n    return pd.Series([random_ipv4() for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_ipv6_series","title":"<code>src.dx.datatypes.misc.generate_ipv6_series(num_rows)</code>","text":"<p>Generate a series of random <code>ipaddress.IPv6Address</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_ipv6_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `ipaddress.IPv6Address` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n\n    def random_ipv6():\n        address_str = \":\".join(\n            str(hex(random.randint(0, 65_535))).replace(\"0x\", \"\") for _ in range(8)\n        )\n        return ipaddress.ip_address(address_str)\n\n    return pd.Series([random_ipv6() for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/misc/#src.dx.datatypes.misc.generate_uuid4_series","title":"<code>src.dx.datatypes.misc.generate_uuid4_series(num_rows)</code>","text":"<p>Generate a series of random <code>uuid.UUID</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/misc.py</code> <pre><code>def generate_uuid4_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `uuid.UUID` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series([uuid.uuid4() for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/numeric/","title":"Numeric","text":""},{"location":"reference/datatypes/numeric/#src.dx.datatypes.numeric.generate_integer_series","title":"<code>src.dx.datatypes.numeric.generate_integer_series(num_rows, value_min=-100, value_max=100)</code>","text":"<p>Generate a series of random <code>integer</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>value_min</code> <code>int</code> <p>Minimum value to generate</p> <code>-100</code> <code>value_max</code> <code>int</code> <p>Maximum value to generate</p> <code>100</code> Source code in <code>src/dx/datatypes/numeric.py</code> <pre><code>def generate_integer_series(\n    num_rows: int, value_min: int = -100, value_max: int = 100\n) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `integer` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    value_min: int\n        Minimum value to generate\n    value_max: int\n        Maximum value to generate\n    \"\"\"\n    return pd.Series([np.random.randint(value_min, value_max) for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/numeric/#src.dx.datatypes.numeric.generate_float_series","title":"<code>src.dx.datatypes.numeric.generate_float_series(num_rows, value_min=0, value_max=0)</code>","text":"<p>Generate a series of random <code>float</code> values. (<code>value_min</code> and <code>value_max</code> both set to <code>0</code> by default since a random <code>0.0</code>-<code>1.0</code> is added.)</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>value_min</code> <code>int</code> <p>Minimum value to generate</p> <code>0</code> <code>value_max</code> <code>int</code> <p>Maximum value to generate</p> <code>0</code> Source code in <code>src/dx/datatypes/numeric.py</code> <pre><code>def generate_float_series(num_rows: int, value_min: int = 0, value_max: int = 0) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `float` values.\n    (`value_min` and `value_max` both set to `0` by default since a random `0.0`-`1.0` is added.)\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    value_min: int\n        Minimum value to generate\n    value_max: int\n        Maximum value to generate\n    \"\"\"\n    return pd.Series(\n        [random.randint(value_min, value_max) + np.random.rand() for _ in range(num_rows)]\n    )\n</code></pre>"},{"location":"reference/datatypes/numeric/#src.dx.datatypes.numeric.generate_decimal_series","title":"<code>src.dx.datatypes.numeric.generate_decimal_series(num_rows, value_min=0, value_max=0)</code>","text":"<p>Generate a series of random <code>decimal.Decimal</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>value_min</code> <code>int</code> <p>Minimum value to generate</p> <code>0</code> <code>value_max</code> <code>int</code> <p>Maximum value to generate</p> <code>0</code> Source code in <code>src/dx/datatypes/numeric.py</code> <pre><code>def generate_decimal_series(num_rows: int, value_min: int = 0, value_max: int = 0) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random `decimal.Decimal` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    value_min: int\n        Minimum value to generate\n    value_max: int\n        Maximum value to generate\n    \"\"\"\n    return generate_float_series(num_rows, value_min, value_max).apply(lambda x: Decimal(x))\n</code></pre>"},{"location":"reference/datatypes/numeric/#src.dx.datatypes.numeric.generate_complex_number_series","title":"<code>src.dx.datatypes.numeric.generate_complex_number_series(num_rows)</code>","text":"<p>Generate a series of random complex numbers.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/numeric.py</code> <pre><code>def generate_complex_number_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random complex numbers.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    return pd.Series(\n        [complex(real=np.random.rand(), imag=np.random.rand()) for _ in range(num_rows)]\n    )\n</code></pre>"},{"location":"reference/datatypes/overview/","title":"Overview","text":"<p>While testing rendering and formatting compatibility across different frameworks, you may need to have quick access to different data types of varying sizes. Below are some convenience functions to help.</p>"},{"location":"reference/datatypes/overview/#dataframe-objects","title":"<code>DataFrame</code> objects","text":"<ul> <li>DataFrames</li> </ul>"},{"location":"reference/datatypes/overview/#series-objects","title":"<code>Series</code> objects","text":"<ul> <li>Numeric</li> <li>Text</li> <li>Datetime</li> <li>Geometry</li> <li>Misc</li> <li>Checking Compatibility</li> </ul>"},{"location":"reference/datatypes/text/","title":"Text","text":""},{"location":"reference/datatypes/text/#src.dx.datatypes.text.generate_text_series","title":"<code>src.dx.datatypes.text.generate_text_series(num_rows)</code>","text":"<p>Generate a series of random long <code>str</code> values. (Requires <code>faker</code> to be installed)</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required Source code in <code>src/dx/datatypes/text.py</code> <pre><code>def generate_text_series(num_rows: int) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random long `str` values. (Requires `faker` to be installed)\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    \"\"\"\n    if not FAKER_INSTALLED:\n        logger.warning(\"faker is not installed, skipping text_column\")\n        return np.nan\n\n    return pd.Series([fake.text() for _ in range(num_rows)])\n</code></pre>"},{"location":"reference/datatypes/text/#src.dx.datatypes.text.generate_keyword_series","title":"<code>src.dx.datatypes.text.generate_keyword_series(num_rows, num_letters=2)</code>","text":"<p>Generate a series of random short <code>str</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>Number of rows to generate</p> required <code>num_letters</code> <code>int</code> <p>Number of letters to use in each keyword</p> <code>2</code> Source code in <code>src/dx/datatypes/text.py</code> <pre><code>def generate_keyword_series(num_rows: int, num_letters: int = 2) -&gt; pd.Series:\n    \"\"\"\n    Generate a series of random short `str` values.\n\n    Parameters\n    ----------\n    num_rows: int\n        Number of rows to generate\n    num_letters: int\n        Number of letters to use in each keyword\n    \"\"\"\n    return pd.Series(\n        [\"\".join(random.sample(string.ascii_uppercase, num_letters)) for _ in range(num_rows)]\n    )\n</code></pre>"}]}